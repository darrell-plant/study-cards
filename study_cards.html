<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b0f14">
  <!-- Inline SVG favicon to prevent 404s and provide an emoji icon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üé¥</text></svg>">

  <title>Study Cards</title>
  <style>
    :root{ --bar-h: 76px; }
    body{font-family:sans-serif;background:#0b0f14;color:#ae9b1c;margin:0}
    
    .wrap{ padding:1rem; }
    .hasBar .wrap{
      padding-bottom: calc(var(--bar-h) + env(safe-area-inset-bottom, 0px));
    }

    textarea{width:100%;min-height:200px;box-sizing:border-box;}
    button{margin:0.20rem;padding:0.6rem 1.1rem;border-radius:12px;border:1px solid #334155;background:#1f2937;color:#facc15;cursor:pointer}
    button:hover{filter:brightness(1.08)}
    /* Disabled buttons look clearly inactive */
    button:disabled{
      background:#111827;          /* darker gray */
      color:#94a3b8;               /* muted text */
      border-color:#263241;        /* dim border */
      opacity:.65;
      cursor:not-allowed;
      filter:none;                 /* cancel hover brightening */
    }
    button:disabled:hover{ filter:none; }
    .iconBtn{padding:0.45rem 0.6rem; line-height:1; border-radius:10px}

    /* Car-mode Pause/Continue styling (taller + bigger text) */
    #pauseBtn {
      font-size: 1.6rem;
      background: #a78bfa;
      color: #1b1130;
      border: 2px solid #c4b5fd;
      text-align: center;
      justify-content: center;
      display: flex;
      align-items: center;
      transition: opacity .18s ease, transform .18s ease, background .25s ease, color .25s ease, border-color .25s ease;
    }

    /* Gentle red when paused (label = Continue) */
    #pauseBtn.paused {
      background: #f87171; /* soft red */
      color: #1b1111;
      border-color: #fca5a5;
    }

    /* Brief fade/scale when swapping labels */
    #pauseBtn.fading{
      opacity: .25;
      transform: scale(0.985);
    }

    .card{border:1px solid #333;padding:0.5rem;margin:0rem;border-radius:12px;background:#121922;box-sizing:border-box}

    .reviewItem{ padding:.5rem .6rem; border-bottom:1px solid #263241; }
    .reviewItem .slug{ color:#93c5fd; font-weight:600; margin-bottom:.2rem; }
    .reviewItem .jp{ color:#a3e635; }
    .reviewItem .en{ color:#facc15; }

    /* Car mode alters card background */
    body.carMode .card{ background:#570f06; }

    /* Show/hide Pause only by carMode */
    body:not(.carMode) #pauseBtn { display:none !important; }
    body.carMode #pauseBtn { display:inline-flex; }

    /* Layout of Pause button within the action bar */
    @media (orientation: portrait){
      body.carMode #pauseBtn{
        order:-1;           /* ensure it appears before the other buttons */
        flex: 1 1 100%;     /* full width on its own row */
      }
      /* Give extra bottom space in portrait when we have two rows */
      body.carMode { --bar-h: 148px; }
    }
    @media (orientation: landscape){
      body.carMode #pauseBtn{
        order:-1;           /* placed before the other buttons */
        flex: 1 1 50%;      /* half width to the left of other actions */
        max-width:50%;
      }
    }

    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center}
    /* Top controls (session header) */
    .topBtn{
      margin: 0.10rem;
      padding: 0.6rem 1.0rem;
      border-radius: 12px;
      border: 2px solid #f3a404a3;
      background: #1f2937;
      color: #facc15;
      cursor: pointer;
      text-align:center;
    }
    .exitBtn {
        background: #facc15;
        color: #3b0707;
        border: 2px solid #f3a404a3;
        font-weight: bold;
    }
    .exitBtn:hover {
      background: #f3a404a3;
    }

    #timerBtn.topBtn {
      min-width:58px;
    }

    .viewerBox{display:grid;gap:10px}
    /* Enable custom horizontal gestures without fighting browser scroll */
    .viewerBox{ touch-action: pan-y; }
    .viewerBox .viewerPanel{ touch-action: pan-y pinch-zoom; }
    .viewerBox .viewerPanel{
      height:26vh;min-height:26vh;max-height:26vh;
      background:#0f1722;border:1px solid #243244;border-radius:12px;
      padding:12px;font-size:2.0rem;line-height:1.6;width:100%;box-sizing:border-box;
      white-space:pre-wrap;user-select:text;overflow:auto;
    }
    @media (orientation: portrait){
      .viewerBox .viewerPanel{
        height:38vh;min-height:38vh;max-height:38vh;
      }
    }
    /* Single-panel mode (large font) */
    .viewerBox.single .viewerPanel{ display:none; }
    .viewerBox.single.showPrompt #promptArea{ display:block; }
    .viewerBox.single.showAnswer #answerArea{ display:block; }
    /* Size the single panel to roughly the combined height of two panels */
    .viewerBox.single .viewerPanel{
      height:59vh; min-height:59vh; max-height:59vh;
    }
    @media (orientation: portrait){
      .viewerBox.single .viewerPanel{
        height:72vh; min-height:72vh; max-height:72vh;
      }
    }
    #promptArea{color:#a3e635;}
    #answerArea{color:#facc15;}

    .bar{position:fixed;left:0;right:0;bottom:0;min-height:var(--bar-h);
      display:flex;align-items:center;justify-content:flex-end;gap:.4rem;
      flex-wrap:wrap;
      padding:0.6rem max(0.8rem, env(safe-area-inset-right));
      padding-bottom:calc(0.6rem + env(safe-area-inset-bottom, 0px));
      background:linear-gradient(180deg,rgba(11,15,20,.0) 0%,#0b0f14 12%,#0b0f14 100%);
      border-top:1px solid #1f2a36;box-sizing:border-box}
    .bar .go{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#3fb950;color:#06200c;border:1px solid #46c35f;min-width:85px;text-align:center}
    .bar .back{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#38bdf8;color:#042635;border:1px solid #7dd3fc}
    .bar .scroll{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#facc15;color:#1f1300;border:1px solid #fde68a}
    .bar .select{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#fb923c;color:#1f1205;border:1px solid #fdba74}
    .bar .go:active,.bar .back:active,.bar .scroll:active{transform:translateY(1px)}
    .bar .aux{background:#1f2937}

    h1{margin:1rem}

    /* Saved sets label */
    label[for="setSelect"], .sectionLabel{ color:#facc15; font-weight:bold; }

    .inline-group{display:flex;align-items:center;gap:.4rem;flex-wrap:wrap}

    /* Hint paragraph colour */
    .hint{ color:#ae9b1c; }
    select:disabled{ opacity:.55; filter:saturate(.6); }

    /* Blocking busy overlay */
    .modalBackdrop{position:fixed;inset:0;background:rgba(2,6,12,.72);display:none;align-items:center;justify-content:center;z-index:9999}
    .modalBox{background:#0f1722;border:1px solid #334155;border-radius:14px;padding:1rem 1.2rem;color:#fefce8;box-shadow:0 10px 28px rgba(0,0,0,.45);min-width:240px;text-align:center}
    .modalBox .spinner{display:inline-block;width:1em;height:1em;border:.18em solid #334155;border-top-color:#3fb950;border-radius:50%;animation:spin 1s linear infinite;margin-right:.5rem;vertical-align:-.14em}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Toast */
    .toast{
      position:fixed; left:50%; transform:translateX(-50%) translateY(6px);
      bottom:calc(var(--bar-h) + 16px);
      background:#1f2937; color:#fefce8; border:1px solid #334155;
      padding:.55rem .8rem; border-radius:12px; font-size:.95rem;
      opacity:0; pointer-events:none; transition:opacity .18s, transform .18s;
      box-shadow:0 6px 20px rgba(0,0,0,.35);
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }

    /* ===== Marquee mode ===== */
    .marqueeWrap{display:flex;flex-direction:column;height:100vh;padding:1rem;box-sizing:border-box}
    #marqueeViewport{flex:2;min-height:66vh;background:#0f1722;border:1px solid #243244;border-radius:12px;overflow:hidden;display:flex;align-items:center;position:relative}
    #marqueeRepeat{position:absolute;top:6px;left:10px;font-size:2rem;font-weight:700;color:#facc15;opacity:.95;user-select:none}
    #marqueeIndex{
      position:absolute; top:6px; right:10px;
      font-size:2rem; font-weight:700;
      color:#facc15; opacity:.95; user-select:none;
      display:none; /* hidden by default; shown for multi */
    }
    #marqueeText{white-space:nowrap;will-change:transform;display:inline-block;padding:0 2rem;font-weight:600;color:#facc15}
    .marqueeControls{flex:1;display:flex;gap:.5rem;align-items:center;justify-content:center}
    .ctrlBtn{
      font-size:1.15rem;
      border-radius:14px;
      background:#1f2937;
      color:#fefce8;
      border:1px solid #334155;
      /* normalize size across emoji/text labels */
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height:56px;           /* pick a consistent height */
      min-width:56px;        /* square-ish for icon-only */
      padding:0 14px;        /* horizontal breathing room */
      line-height:1;         /* avoid emoji baseline variance */
      vertical-align:middle; /* align in rows nicely */
      appearance: none;
      -webkit-appearance: none;
    }
    .ctrlBtn.scroll{background:#facc15;color:#1f1300;border:1px solid #fde68a}

    /* Marquee fullscreen overlay */
    #marqueeCard.fullscreen{ position:fixed; inset:0; margin:0; border-radius:0; padding:0; z-index:1000; }
    /* Keep control buttons inside and wrap on small screens */
    .marqueeControls{ flex-wrap:wrap; padding:0 1rem 1rem; box-sizing:border-box }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="inputCard" class="card">
      <h1 id="headerTitle">Study Cards</h1>
      <p class="hint">
        <span class="fsOnly">Use üìÅ to select a folder to store sentence files.<br>
        Use üîå to reconnect folder.<br>
        Grant permissions when prompted.<br></span>
        Use üîÑ to get the latest sentence files.
      </p>

      <!-- Library controls -->
      <div class="inline-group">
        <span class="sectionLabel" aria-hidden="true">Library</span>
        <button id="switchFolderBtn" class="iconBtn" title="Pick a different folder" aria-label="Pick a different folder">üìÅ</button>
        <button id="reconnectFolderBtn" class="iconBtn" title="Reconnect stored folder" aria-label="Reconnect stored folder">üîå</button>
        <button id="syncLibraryBtn" class="iconBtn" title="Sync library into folder" aria-label="Sync library into folder">üîÑ</button>
      </div>

      <!-- Groups controls (shown only if subfolders exist) -->
      <div class="inline-group" id="groupsRow" style="display:none">
        <label for="groupSelect" class="sectionLabel">Group</label>
        <select id="groupSelect" disabled>
          <option value="__base__">&lt;base&gt;</option>
        </select>
      </div> 

      <!-- Cards controls -->
      <div class="inline-group">
        <label for="setSelect">Card</label>
        <select id="setSelect" multiple size="4" disabled>
          <option value="">(none)</option>
        </select>
        <button id="deleteSetBtn" class="iconBtn" title="Delete saved state (keeps file)" aria-label="Delete saved state (keeps file)">üóë</button>
        <button id="deleteFileBtn" class="iconBtn" title="Delete set file (destructive)" aria-label="Delete set file">üíÄ</button>
      </div>
      <br>

      <textarea id="pairs" placeholder="NAME: Example

„Åì„Çì„Å´„Å°„ÅØ
Hello

„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô
Thank you

„Åô„Åø„Åæ„Åõ„Çì
Excuse me"></textarea><br>

      <button id="startBtn" disabled>Start session</button>
      <button id="marqueeBtnStart" disabled>Scroll</button>
      <button id="carModeBtn" title="Toggle car mode" aria-label="Toggle car mode">üè†</button>
      <button id="saveBtn" type="button" title="Save to file" aria-label="Save to file" disabled>üíæ</button>
      <!-- Review controls (Home only) -->
      <div class="inline-group" style="margin-top:.5rem">
        <button id="reviewBtn" class="actionBtn" title="Review difficult cards" aria-label="Review difficult cards">Review</button>
      </div>
    </div>

    <div id="sessionCard" class="card" style="display:none">
      <div class="row" style="justify-content:space-between; margin-bottom:.5rem">
        <div id="progress"></div>
        <div>
          <button id="backBtnTop" class="topBtn exitBtn" title="Exit Session">Exit</button>
          <button id="reverseBtn" class="topBtn" title="Flip JP‚ÜîEN for this session">EN</button>
          <button id="shuffleTopBtn" class="topBtn">Mix</button>
          <button id="timerBtn" class="topBtn" title="Auto reveal/advance">0s</button>
        </div>
      </div>

      <div class="viewerBox">
        <div id="promptArea" class="viewerPanel" role="textbox" aria-readonly="true" tabindex="0"></div>
        <div id="answerArea" class="viewerPanel" role="textbox" aria-readonly="true" tabindex="0"></div>
      </div>
      
      <div class="bar" id="actionBar" style="display:none">
        <button id="pauseBtn" class="topBtn">Pause</button>
        <button id="marqueeBtnSession" class="scroll">Scroll</button>
        <button id="selectBtn" class="select">Select</button>
        <button id="backStepBtn" class="back">Back</button>
        <button id="goBtn" class="go">Go</button>
      </div>

    </div>

    <div id="marqueeCard" class="card" style="display:none; padding:0;">
      <div class="marqueeWrap">
        <div id="marqueeViewport">
          <div id="marqueeText" style="font-size:72px;"></div>
          <div id="marqueeRepeat" title="Repeats per item">3</div>
          <div id="marqueeIndex"  title="Position"></div>
        </div>
        <div class="marqueeControls">
          <button id="fontDownBtn" class="ctrlBtn">A‚àí</button>
          <button id="fontUpBtn" class="ctrlBtn">A+</button>
          <button id="speedDownBtn" class="ctrlBtn">‚¨áÔ∏è</button>
          <button id="speedUpBtn" class="ctrlBtn">‚¨ÜÔ∏è</button>
          <button id="prevLineBtn" class="ctrlBtn" title="Previous">‚óÄ</button>
          <button id="nextLineBtn" class="ctrlBtn" title="Next">‚ñ∂</button>
          <button id="abLoopBtn" class="ctrlBtn" title="Set A / Set B / Reset">a</button>
          <button id="exitMarqueeBtn" class="ctrlBtn scroll">Exit</button>
        </div>
      </div>
    </div>

    <div id="reviewCard" class="card" style="display:none">
      <div class="row" style="justify-content:space-between; margin-bottom:.5rem">
        <div id="reviewCount">Difficult: 0</div>
        <div>
          <button id="reviewBackBtn" class="topBtn">Back</button>
          <button id="reviewClearBtn" class="topBtn">Clear</button>
          <button id="reviewExportBtn" class="topBtn" title="Copy difficult cards to clipboard">Export</button>
        </div>
      </div>
      <div id="reviewList" class="card" style="max-height:70vh; overflow:auto"></div>
      <div class="row" style="justify-content:center; margin-top:.6rem">
        <button id="reviewNewDeckBtn" class="topBtn" title="Create new deck from Difficult">New Deck</button>
      </div>
    </div>

  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <div id="busy" class="modalBackdrop" role="dialog" aria-live="polite" aria-modal="true">
    <div class="modalBox"><span class="spinner" aria-hidden="true"></span><span id="busyMsg">Downloading‚Ä¶</span></div>
  </div>

  <script src="js/fs-driver.js"></script>
  <script src="js/idb-driver.js"></script>

<script>
    // ---- Driver selection (FS vs IDB) ----
    const qs = new URLSearchParams(location.search);
    const forcedDriver = qs.get('driver'); // 'fs' | 'idb' | null
    const supportsFS = !!(window.showDirectoryPicker && window.isSecureContext);
    const DRIVER = forcedDriver ? forcedDriver : (supportsFS ? 'fs' : 'idb');

    // Hide FS-only UI when running in IDB mode
    if (DRIVER === 'idb') {
      // Hide the FS-only hint lines
      document.addEventListener('DOMContentLoaded', () => {
        document.querySelectorAll('.fsOnly, #switchFolderBtn, #reconnectFolderBtn').forEach(el => {
          if (el) el.style.display = 'none';
        });
      });
    }

    // ---- Storage drivers
    const storage = (DRIVER === 'fs') ? window.fsDriver : window.idbDriver;

    const $=id=>document.getElementById(id);

    let dirHandle = null;           // chosen /sentences directory
    // Current group (subfolder) selection within chosen folder
    const BASE_GROUP = "__base__";  // UI shows as <base>
    let currentGroup = BASE_GROUP;
    const EXT = '.data';            // deck file extension

    // Map slug -> stored IDB path (e.g., "miku/000_test.data")
    const idbPathBySlug = new Map();

    // Car mode (not persisted); affects single-panel threshold and default font
    let carMode = false; // default non-car on startup
    function applyCarModeUI(){
      document.body.classList.toggle('carMode', carMode);
      updatePauseButtonEnabled();
      const btn = $('carModeBtn');
      if(btn) btn.textContent = carMode ? 'üöó' : 'üè†';
    }
    function setCarMode(on){
      carMode = !!on;
      // Reset font size based on mode (persist font size itself as usual)
      viewFontRem = carMode ? 2.6 : 2.0;
      localStorage.setItem(VIEW_FONT_KEY, String(viewFontRem));
      applyCarModeUI();
      applyViewFont();
      if (carMode) acquireWakeLock(); else releaseWakeLock();
    }

    // -------- Beep (car-mode only) --------
    let _audioCtx = null;
    function ensureAudio(){
      if(!_audioCtx){
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if(Ctx) _audioCtx = new Ctx();
      }
      return _audioCtx;
    }
    function playBeep(freq=880, dur=0.08, vol=0.2){
      if(!carMode) return;                    // only in car-mode
      const ctx = ensureAudio(); if(!ctx) return;
      const now = ctx.currentTime;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, now);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(vol, now + 0.005);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.connect(gain).connect(ctx.destination);
      osc.start(now);
      osc.stop(now + dur + 0.02);
    }
    // Convenience beeps for state changes
    function beepReveal(){ playBeep(1200, 0.09, 0.4); } // higher pitch on reveal
    function beepNext(){   playBeep(700,  0.09, 0.4); } // lower pitch on next/return

    // Library sync configuration (repo-hosted files)
    const LIB_INDEX_URL = 'library/index.json';  // GH Pages path to library manifest
    const LIB_TARGET_SUBDIR = '';                // write library decks into the chosen folder root
    const SYNC_POLICY = 'overwriteChanged';      // 'addNewOnly' | 'overwriteChanged' | 'forceOverwriteAll'

    function slugFromFilename(name){
      return name.replace(/\.[^.]+$/, '');
    }
    function filenameFromSlug(slug){
      return `${slug}${EXT}`;
    }

    function pathForSlug(slug){
      const fn = filenameFromSlug(slug);
      if (DRIVER === 'idb'){
        // For IDB, path key is group/filename or filename for base
        return (currentGroup && currentGroup !== '__base__') ? `${currentGroup}/${fn}` : fn;
      }
      // FS driver uses group folders, but this is not consumed directly
      return fn;
    }

    async function chooseSentencesFolder(){
      try{
        dirHandle = await window.showDirectoryPicker({ mode:'readwrite' });
        if (window.fsDriver) window.fsDriver.setRoot(dirHandle);
        await navigator.storage?.persist?.();   // request persistent storage
        await idbSet('sentencesDir', dirHandle);
        $('setSelect').disabled = false;
        await populateGroupSelect();

        // Try to restore saved group in this new folder
        try{
          const savedGroup = localStorage.getItem(SELECTED_GROUP_KEY);
          if(savedGroup){
            const sel = $('groupSelect');
            if([...sel.options].some(o=>o.value===savedGroup)){
              sel.value = savedGroup;
              currentGroup = savedGroup;
            } else {
              currentGroup = BASE_GROUP;
              sel.value = BASE_GROUP;
            }
          }
        }catch{}

        await populateSetSelectFromDir();

        // Try to restore saved card within this group
        try{
          const savedCard = localStorage.getItem(SELECTED_CARD_KEY);
          if(savedCard){
            const sel = $('setSelect');
            if([...sel.options].some(o=>o.value===savedCard)){
              sel.value = savedCard;
              const base = await getGroupDirHandle(currentGroup);
              const fh = await base.getFileHandle(filenameFromSlug(savedCard));
              let t = await readFileText(fh);
              const name = titleCase(slugToNiceName(savedCard));
              const pairs = parsePairs(t);
              t = normalizeDeckTop(t, name, 1, pairs.length);
              $('pairs').value = t;
            } else {
              try{ localStorage.removeItem(SELECTED_CARD_KEY); }catch{}
              $('pairs').value = '';
            }
          } else {
            $('pairs').value = '';
          }
        }catch{ $('pairs').value = ''; }

        showToast('Folder selected');
      }catch(err){
        // user cancelled; keep disabled state
      }
    }

    async function listDataFiles(group = currentGroup){
      if (DRIVER === 'idb') {
        const items = await storage.listFiles(group);
        // Adapt to existing shape: {name, handle}
        // We only use .name downstream, so a dummy handle is fine.
        return items.map(it => ({ name: it.name, handle: null, _path: it.path, _display: it.display }));
      }

      if(!dirHandle) return [];
      const base = await getGroupDirHandle(group);
      if(!base) return [];
      const files=[];
      for await (const [name, handle] of base.entries()){
        if(handle.kind==='file' && name.toLowerCase().endsWith(EXT)){
          files.push({ name, handle });
        }
      }
      const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
      files.sort((a,b)=>coll.compare(a.name,b.name));
      return files;
    }

    async function readFileText(fileHandle){
      const file = await fileHandle.getFile();
      return await file.text();
    }

    async function writeFileText(slug, text){
      if(!dirHandle) throw new Error('No folder selected');
      const base = await getGroupDirHandle(currentGroup);
      const fh = await base.getFileHandle(filenameFromSlug(slug), { create:true });
      const ws = await fh.createWritable();
      await ws.write(text);
      await ws.close();
    }

    async function saveCurrentTextareaToFile(){
      try{ showToast('Saving‚Ä¶'); }catch{}
      const txtArea = $('pairs');
      if(!txtArea) return;

      const slugs = getSelectedSlugs();
      // Validate header
      const currentHeader = headerNameFromTextarea();
      if(!currentHeader){
        const sb=$('saveBtn'); if(sb) sb.disabled = true;
        showToast('Add a NAME: header first');
        return;
      }

      // Clean header line (strip any counts) and normalize spacing after header
      const lines = txtArea.value.split(/\r?\n/);
      lines[0] = `NAME: ${titleCase(currentHeader)}`;
      let cleanedText = lines.join('\n');
      cleanedText = cleanedText.replace(/^(NAME:.*?)(\r?\n\s*)+/, '$1\n\n');

      // Decide target slug:
      // - Single selection + unchanged header => overwrite
      // - Otherwise write a new file using header-derived slug (ensure unique)
      const selectedSlug = (slugs.length === 1) ? slugs[0] : '';
      const baselineDisplay = selectedSlug ? titleCase(slugToNiceName(selectedSlug)) : '';
      const headerDisplay   = titleCase(currentHeader);
      let targetSlug;
      if (selectedSlug && headerDisplay === baselineDisplay){
        targetSlug = selectedSlug;
      } else {
        targetSlug = await ensureUniqueSlug(slugify(headerDisplay));
      }

      if (DRIVER === 'idb'){
        // Resolve a key path. Prefer existing stored path if overwriting.
        let targetPath;
        if (selectedSlug && targetSlug === selectedSlug){
          const stored = idbPathBySlug.get(selectedSlug);
          const computed = pathForSlug(selectedSlug);
          targetPath = stored || computed;
        } else {
          targetPath = pathForSlug(targetSlug);
        }

        await storage.writeFile(targetPath, cleanedText);
        await populateGroupSelect();               // groups may change if header/slug implies new file name
        await populateSetSelectFromDir(targetSlug);
        try{ localStorage.setItem(SELECTED_CARD_KEY, targetSlug); }catch{}
        showToast(targetSlug === selectedSlug ? 'Saved' : 'Saved as new');
        return;
      }

      // FS driver (original flow)
      if(!dirHandle){
        await chooseSentencesFolder();
        if(!dirHandle){ showToast('No folder selected'); return; }
      }
      try{
        const base = await getGroupDirHandle(currentGroup);
        const fh = await base.getFileHandle(filenameFromSlug(targetSlug), { create:true });
        const ws = await fh.createWritable();
        await ws.write(cleanedText);
        await ws.close();
        await populateSetSelectFromDir(targetSlug);
        try{ localStorage.setItem(SELECTED_CARD_KEY, targetSlug); }catch{}
        showToast(targetSlug === selectedSlug ? 'Saved' : 'Saved as new');
      }catch(err){
        const ok = await saveViaPickerFallback(filenameFromSlug(targetSlug), cleanedText);
        if(!ok){
          alert('Unable to save the file. Try a different folder using üìÅ Switch folder.');
        } else {
          await populateSetSelectFromDir('');
        }
      }
    }
    $('deleteFileBtn').onclick = async () => {
      const slugs = getSelectedSlugs();
      if(!slugs.length){ showToast('No Card selected'); return; }

      if (DRIVER === 'idb'){
        let n=0, err=0;
        for(const slug of slugs){
          try{
            const stored = idbPathBySlug.get(slug);
            const path = stored || pathForSlug(slug);
            await storage.deleteFile(path);
            n++;
          }catch{ err++; }
        }
        await populateGroupSelect();
        await populateSetSelectFromDir('');
        $('pairs').value = '';
        updateStartEnabled();
        showToast(err?`Deleted ${n}, ${err} failed`:`Deleted ${n}`);
        return;
      }

      // FS mode: remove actual files from the chosen group directory
      if(!dirHandle){ showToast('Pick a folder first'); return; }
      try{
        const base = await getGroupDirHandle(currentGroup);
        let n=0, err=0;
        for(const slug of slugs){
          try{
            await base.removeEntry(filenameFromSlug(slug));
            n++;
          }catch{ err++; }
        }
        await populateSetSelectFromDir('');
        $('pairs').value = '';
        updateStartEnabled();
        showToast(err?`Deleted ${n}, ${err} failed`:`Deleted ${n}`);
      }catch{
        showToast('Delete failed');
      }
    };

    async function saveViaPickerFallback(filename, text){
      if(!window.showSaveFilePicker) return false;
      try{
        const fh = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: 'Sentence data', accept: { 'text/plain': ['.data', '.txt'] } }]
        });
        const ws = await fh.createWritable();
        await ws.write(text);
        await ws.close();
        showToast('Saved via picker');
        return true;
      }catch{
        return false;
      }
    }

    // Attempt to restore access via user gesture; fall back to picking
    async function ensureFolderAccessInteractive(){
      try{
        // Try restore from IndexedDB
        if(!dirHandle){
          const h = await idbGet('sentencesDir');
          if(h) dirHandle = h;
        }
        if(dirHandle){
          // Check current permission
          let q = await dirHandle.queryPermission({ mode:'readwrite' });
          if(q !== 'granted'){
            // Must be triggered by a user gesture (button tap)
            q = await dirHandle.requestPermission({ mode:'readwrite' });
          }
          if(q === 'granted'){
            // Reuse the existing handle; do NOT open the picker again
            if (window.fsDriver) window.fsDriver.setRoot(dirHandle);
            $('setSelect').disabled = false;
            await populateGroupSelect();
            await populateSetSelectFromDir();
            showToast('Folder reconnected');
            return true;
          }
          // Permission denied or dismissed ‚Äî fall through to re-pick
        }
        // If we get here, either no handle or permission not granted: pick anew
        await chooseSentencesFolder();
        return !!dirHandle;
      }catch(err){
        return false;
      }
    }

    // --- Network & file helpers for Library sync ---
    async function fetchTextScoped(path){
      const url = new URL(path, location.href).toString();
      const res = await fetch(url, { cache: 'no-cache' });
      if(!res.ok) throw new Error(`Fetch ${path} ${res.status}`);
      return await res.text();
    }
    async function fetchJSONScoped(path){
      return JSON.parse(await fetchTextScoped(path));
    }
    async function ensureSubdir(dirHandle, name){
      return name ? await dirHandle.getDirectoryHandle(name, { create:true }) : dirHandle;
    }

    async function listSubdirs(){
      if(!dirHandle) return [];
      const dirs = [];
      for await (const [name, handle] of dirHandle.entries()){
        if(handle.kind === 'directory') dirs.push({ name, handle });
      }
      const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
      dirs.sort((a,b)=>coll.compare(a.name,b.name));
      return dirs;
    }
    async function getGroupDirHandle(group){
      if(!dirHandle) return null;
      if(!group || group === BASE_GROUP) return dirHandle;
      try { return await dirHandle.getDirectoryHandle(group); }
      catch { return null; }
    }

    // Helper: ensure all subdirs for a relative path, return { dir, filename }
    async function ensurePath(dirHandle, relPath){
      // Normalize and split the relative path into parts; last part is filename
      const clean = String(relPath||'').replace(/^\/*/,'').replace(/^library\//,'');
      const parts = clean.split('/').filter(Boolean);
      let dir = dirHandle;
      for(let i=0;i<parts.length-1;i++){
        const seg = parts[i];
        dir = await dir.getDirectoryHandle(seg, { create:true });
      }
      const filename = parts[parts.length-1] || '';
      return { dir, filename };
    }
    async function fileExists(dir, filename){
      try { await dir.getFileHandle(filename); return true; }
      catch { return false; }
    }
    async function readFileIfExists(dir, filename){
      try { const fh = await dir.getFileHandle(filename); const f = await fh.getFile(); return await f.text(); }
      catch { return null; }
    }

    // --- Sync Library (repo) into chosen folder ---
    async function syncLibraryIntoFolder(){
        showBusy('Downloading sentences...');
        try{
          if(!dirHandle){
          const picked = await chooseSentencesFolder();
          if(!dirHandle) return; // user cancelled
        }
        let index;
        try {
          index = await fetchJSONScoped(LIB_INDEX_URL);
        } catch (e) {
          showToast('Library index not available');
          return;
        }
        const files = index.files || [];
        if(!files.length){ showToast('Library is empty'); return; }

        const targetDir = await ensureSubdir(dirHandle, LIB_TARGET_SUBDIR);
        let wrote = 0, skipped = 0, errors = 0;

        for(const item of files){
          const rel = typeof item === 'string' ? item : (item.path || item.file || item.name);
          if(!rel) continue;
          try{
            // Normalize relative path under /library (remote) and local dir structure
            const relNorm = String(rel).replace(/^library\//,'').replace(/^\/*/,'');
            const { dir, filename } = await ensurePath(targetDir, relNorm);

            // Fetch the remote text using the same relative structure under /library
            const libText = await fetchTextScoped('library/' + relNorm);

            if(SYNC_POLICY === 'addNewOnly'){
              if(await fileExists(dir, filename)){ skipped++; continue; }
              const fh = await dir.getFileHandle(filename, { create:true });
              const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++; continue;
            }

            if(SYNC_POLICY === 'overwriteChanged'){
              const current = await readFileIfExists(dir, filename);
              if(current !== null && current === libText){ skipped++; continue; }
              const fh = await dir.getFileHandle(filename, { create:true });
              const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++; continue;
            }

            // 'forceOverwriteAll'
            const fh = await dir.getFileHandle(filename, { create:true });
            const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++;
          }catch(err){
            console.warn('Sync fail', rel, err);
            errors++;
          }
        }

        await populateGroupSelect();
        await populateSetSelectFromDir();
        showToast(`Library sync: ${wrote} wrote, ${skipped} skipped${errors?`, ${errors} errors`:''}`);
      } finally {
        hideBusy();
      }
    }

    // --- IndexedDB for persisting FileSystemHandles ---
    const DB_NAME='sc_fs_db', STORE='handles';
    function idbOpen(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e)=>{ e.target.result.createObjectStore(STORE); };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }
    async function idbSet(key, value){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readwrite');
        tx.oncomplete=()=>resolve();
        tx.onerror=()=>reject(tx.error);
        tx.objectStore(STORE).put(value, key);
      });
    }
    async function idbGet(key){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readonly');
        const req = tx.objectStore(STORE).get(key);
        req.onsuccess=()=>resolve(req.result);
        req.onerror=()=>reject(req.error);
      });
    }
    async function idbDel(key){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readwrite');
        tx.oncomplete=()=>resolve();
        tx.onerror=()=>reject(tx.error);
        tx.objectStore(STORE).delete(key);
      });
    }

    async function populateGroupSelect(){
      const row = $('groupsRow');
      const sel = $('groupSelect');
      const prevGroup = currentGroup;

      // ===== IDB driver: list groups from IndexedDB =====
      if (DRIVER === 'idb') {
        try{
          const groups = await storage.listGroups(); // e.g., ['__base__','miku',...]
          const hasSub = groups.some(g => g !== BASE_GROUP);

          if(!hasSub){
            // No subfolders in IDB ‚Üí hide row, lock to <base>
            row.style.display='none';
            sel.disabled = true;
            sel.innerHTML = '<option value="__base__">&lt;base&gt;</option>';
            currentGroup = BASE_GROUP;
          } else {
            row.style.display='';
            sel.disabled = false;
            sel.innerHTML = '<option value="__base__">&lt;base&gt;</option>';
            for(const g of groups){
              if(g === BASE_GROUP) continue;
              const opt = document.createElement('option');
              opt.value = g;
              opt.textContent = truncateString(g);
              opt.title = g;
              sel.appendChild(opt);
            }
            const saved = localStorage.getItem(SELECTED_GROUP_KEY) || prevGroup || BASE_GROUP;
            const names = new Set(groups);
            const toSet = names.has(saved) ? saved : BASE_GROUP;
            sel.value = toSet;
            currentGroup = toSet;
          }

          if (currentGroup !== prevGroup) await populateSetSelectFromDir('');
          return; // important: don't fall through to FS branch
        }catch(e){
          console.warn('[idb] populateGroupSelect failed', e);
          // fall through to FS branch if something went wrong
        }
      }

      // ===== FS driver (existing behavior) =====
      if(!dirHandle){
        row.style.display='none';
        sel.disabled=true;
        currentGroup = BASE_GROUP;
        if (currentGroup !== prevGroup) await populateSetSelectFromDir('');
        return;
      }

      const dirs = await listSubdirs();
      if(!dirs.length){
        row.style.display='none';
        sel.disabled=true;
        currentGroup = BASE_GROUP;
        sel.innerHTML = '<option value="__base__">&lt;base&gt;</option>';
        if (currentGroup !== prevGroup) await populateSetSelectFromDir('');
        return;
      }

      row.style.display='';
      sel.disabled = false;
      const prev = sel.value || currentGroup || BASE_GROUP;
      sel.innerHTML = '<option value="__base__">&lt;base&gt;</option>';
      for(const d of dirs){
        const opt = document.createElement('option');
        opt.value = d.name;
        opt.textContent = truncateString(d.name);
        opt.title = d.name;
        sel.appendChild(opt);
      }
      const names = new Set([BASE_GROUP, ...dirs.map(d=>d.name)]);
      const toSet = names.has(prev) ? prev : BASE_GROUP;
      sel.value = toSet;
      currentGroup = toSet;

      if (currentGroup !== prevGroup) await populateSetSelectFromDir('');
    }

    async function populateSetSelectFromDir(selectedSlug=''){
      idbPathBySlug.clear();
      const sel=$('setSelect');
      const currentVal = sel.value;
      sel.innerHTML='<option value="">(none)</option>';
      const files = await listDataFiles(currentGroup);
      
      const items = files.map(f=>{
        const slug = slugFromFilename(f.name);
        const display = f._display ? f._display : titleCase(slugToNiceName(slug));
        const path = f._path || f.path || null; // <-- pick up real IDB key if provided
        return { slug, display, _path: path };
      });

      const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
      items.sort((a,b)=>coll.compare(a.display,b.display)||a.slug.localeCompare(b.slug));

      for (const {slug, display, _path} of items){
        const opt = document.createElement('option');
        opt.value = slug;
        opt.textContent = truncateString(display);
        opt.title = display;
        sel.appendChild(opt);
        if (_path) idbPathBySlug.set(slug, _path);   // <-- will now be set correctly
      }

      const toSet = selectedSlug || (items.some(i=>i.slug===currentVal)? currentVal : '');
      sel.value = toSet;
      sel.disabled = false;
    }

    function getSelectedSlugs(){
      const sel = $('setSelect');
      if(!sel) return [];
      const out = [];
      for(const opt of sel.selectedOptions){
        if(opt.value) out.push(opt.value);
      }
      return out;
    }

    // Read one deck‚Äôs text (raw file) and return parsed pairs (header ignored).
    async function readDeckPairsForSlug(slug){
      if (DRIVER === 'idb') {
        const filename = filenameFromSlug(slug);
        const computed = (currentGroup && currentGroup !== '__base__') ? `${currentGroup}/${filename}` : filename;
        const stored   = idbPathBySlug.get(slug);
        const path     = stored || computed;
        const raw = await storage.readFile(path);
        const txt = await normalizeReadResult(raw);
        return parsePairs(txt);
      }
      // FS path (unchanged)
      const base = await getGroupDirHandle(currentGroup);
      const fh   = await base.getFileHandle(filenameFromSlug(slug));
      const txt  = await readFileText(fh);
      return parsePairs(txt);
    }

    // Build a combined textarea text and pairs for N slugs.
    // - Produces: NAME: Combined (N)
    // - Then all pairs (JP/EN) concatenated with exactly one blank line between pairs.
    async function buildCombinedFromSelected(slugs){
      const allPairs = [];
      for(const slug of slugs){
        try{
          const ps = await readDeckPairsForSlug(slug);
          if(ps && ps.length) allPairs.push(...ps);
        }catch{
          // skip missing/unreadable files
        }
      }
      const setsCount = slugs.length;
      const pairCount = allPairs.length;
      let text = `NAME: Combined (${setsCount} / ${pairCount})\n\n`;
      text += allPairs.map(([jp,en])=>`${jp}\n${en}`).join('\n\n');
      if(text && !text.endsWith('\n')) text += '\n';
      return { text, pairs: allPairs, setsCount, pairCount };
    }

    // ===== Marquee mode state =====
    const MARQUEE_FONT_KEY = 'sc_marquee_font';
    const MARQUEE_SPEED_KEY = 'sc_marquee_speed'; // px per second

    const marquee = {
      lines: [],
      cursor: 0,        // current index being shown
      running: false,
      caller: 'start',  // 'start' or 'session'
      fontPx: Math.max(24, +(localStorage.getItem(MARQUEE_FONT_KEY)||72)),
      pxPerSec: Math.max(20, +(localStorage.getItem(MARQUEE_SPEED_KEY)||80)),
      repeatMax: 3,
      repeatRemaining: 0,
      currentRAF: null,
      animToken: 0,
      loop: { a: null, b: null, enabled: false, stage: 0 } // stage: 0->set A, 1->set B, 2->enable loop, 3->reset
    };
    function updateRepeatCounterDisplay(){
      const el = $('marqueeRepeat');
      if(!el) return;
      el.textContent = String(Math.max(1, marquee.repeatRemaining||marquee.repeatMax||3));
      // Match marquee text color
      try{ el.style.color = getComputedStyle($('marqueeText')).color; }catch{}
    }

    function setRepeatMax(n){
      marquee.repeatMax = Math.max(1, Math.min(10, (n|0)||3));
      // Reset remaining for current item to full count
      marquee.repeatRemaining = marquee.repeatMax;
      updateRepeatCounterDisplay();
    }

    function cycleRepeatMax(){
      let n = marquee.repeatMax;
      n = (n % 10) + 1; // 1..10 cycle
      setRepeatMax(n);
      // Restart current line to reflect new countdown immediately
      if(marquee.running && marquee.lines.length){
        stopMarqueeLoop();
        marquee.running = true;
        showLineAt(marquee.cursor);
      }
    }

    // --- Wake Lock (keep screen on during Marquee) ---
    let wakeLock = null;
    async function acquireWakeLock(){
      if(!('wakeLock' in navigator)) return; // not supported
      try{
        if(!wakeLock){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener?.('release',()=>{ wakeLock = null; });
        }
      }catch(err){ /* ignore (e.g., tab not visible) */ }
    }
    function releaseWakeLock(){
      try{ wakeLock && wakeLock.release && wakeLock.release(); }catch{}
      wakeLock = null;
    }

    function setMarqueeFont(px){
      marquee.fontPx = Math.max(24, Math.min(200, px|0));
      localStorage.setItem(MARQUEE_FONT_KEY, marquee.fontPx);
      $('marqueeText').style.fontSize = marquee.fontPx + 'px';
    }

    function setMarqueeSpeed(pxPerSec){
      marquee.pxPerSec = Math.max(20, Math.min(600, pxPerSec|0));
      localStorage.setItem(MARQUEE_SPEED_KEY, marquee.pxPerSec);
    }

    function restartMarqueeWithNewSpeed(){
      if(!marquee.running) return;
      const el = $('marqueeText');
      const vp = $('marqueeViewport');
      let tx = 0;
      const tr = getComputedStyle(el).transform;
      if(tr && tr !== 'none'){
        const m = tr.match(/matrix\([^,]+,[^,]+,[^,]+,[^,]+,([^,]+),([^\)]+)\)/);
        if(m){ tx = parseFloat(m[1]) || 0; }
      }
      const textWidth = el.scrollWidth;
      if(!isFinite(tx) || tx === 0){ tx = vp.clientWidth; }
      el.style.transition = 'none';
      el.style.transform = `translateX(${tx}px)`;
      void el.offsetWidth;
      const remaining = Math.abs(tx - (-textWidth));
      const durationSec = remaining / marquee.pxPerSec;
      el.style.transition = `transform ${durationSec}s linear`;
      el.style.transform = `translateX(${-textWidth}px)`;
    }

    // ==== Marquee helpers for looping and navigation ====
    function marqueeHasMultiple(){ return marquee.lines && marquee.lines.length > 1; }
    function currentIndex(){ return marquee.cursor % marquee.lines.length; }
    function normalizeRange(){
      if(marquee.loop.a==null || marquee.loop.b==null) return;
      if(marquee.loop.a===marquee.loop.b) return; // single-item loop ok
      if(marquee.loop.a > marquee.loop.b){ const t = marquee.loop.a; marquee.loop.a = marquee.loop.b; marquee.loop.b = t; }
    }

    function hasLoop(){ return !!(marquee.loop.enabled && marquee.loop.a!=null && marquee.loop.b!=null); }

    function nextIndex(){
      const n = marquee.lines.length; if(!n) return 0;
      if(hasLoop()){
        const a = marquee.loop.a % n, b = marquee.loop.b % n; // normalizeRange() ensures a<=b
        return (marquee.cursor === b) ? a : (marquee.cursor + 1) % n;
      }
      return (marquee.cursor + 1) % n;
    }

    function prevIndex(){
      const n = marquee.lines.length; if(!n) return 0;
      if(hasLoop()){
        const a = marquee.loop.a % n, b = marquee.loop.b % n; // a<=b guaranteed
        return (marquee.cursor === a) ? b : (marquee.cursor - 1 + n) % n;
      }
      return (marquee.cursor - 1 + n) % n;
    }

    function updateABButtonLabel(){
      const st = marquee.loop.stage % 3;
      const btn = $('abLoopBtn');
      const label = ['a','b','r'][st];
      btn.textContent = label;
      btn.style.background = '#1f2937';
      btn.style.color = '#fefce8';
      if(label === 'b'){
        btn.style.background = '#16a34a';
        btn.style.color = '#fefce8';
      } else if(label === 'r'){
        btn.style.background = '#dc2626';
        btn.style.color = '#fefce8';
      }
    }

    function showMarqueeScreen(){
      cancelCardTimers();
      $('inputCard').style.display='none';
      $('sessionCard').style.display='none';
      $('actionBar').style.display='none';
      $('marqueeCard').style.display='block';
      // Initialize font each time shown (in case user changed settings)
      setMarqueeFont(marquee.fontPx);
      document.body.classList.remove('hasBar'); // marquee has its own controls, no fixed bar
      // Make marquee full-screen and hide header/scroll
      $('marqueeCard').classList.add('fullscreen');
      document.body.style.overflow = 'hidden';
    }

    function hideMarqueeScreen(){
      $('marqueeCard').classList.remove('fullscreen');
      document.body.style.overflow = '';
      $('marqueeCard').style.display='none';
      // restore previous caller screen
      if (marquee.caller === 'session') {
        $('sessionCard').style.display='block';
        $('actionBar').style.display='flex';
        document.body.classList.add('hasBar');
        // Resume study timer when returning from Scroll mode to session
        updateTimerLabel();
        scheduleCardTimer();
      } else {
        $('inputCard').style.display='block';
        document.body.classList.remove('hasBar');
      }
    }

    // ==== Refactored Marquee play logic ====
    function playMarqueeLine(text, onDone){
      const vp = $('marqueeViewport');
      const el = $('marqueeText');
      el.textContent = text;
      el.style.transition = 'none';
      const token = ++marquee.animToken; // unique id for this animation
      const startX = vp.clientWidth;
      el.style.transform = `translateX(${startX}px)`;
      void el.offsetWidth;
      const textWidth = el.scrollWidth;
      const distance = startX + textWidth;
      const durationSec = distance / marquee.pxPerSec;
      el.style.transition = `transform ${durationSec}s linear`;
      el.style.transform = `translateX(${-textWidth}px)`;
      const handler = () => {
        el.removeEventListener('transitionend', handler);
        if(token === marquee.animToken){ onDone && onDone(); }
      };
      el.addEventListener('transitionend', handler);
    }

    function showLineAt(i){
      if(!marquee.lines.length) return;
      marquee.cursor = (i+marquee.lines.length) % marquee.lines.length;

      // reset repeats & counters
      marquee.repeatRemaining = marquee.repeatMax;
      updateRepeatCounterDisplay();
      updateMarqueeIndexDisplay(); // <-- add this

      const doOnePass = ()=>{
        updateRepeatCounterDisplay();
        playMarqueeLine(marquee.lines[marquee.cursor], ()=>{
          if(!marquee.running) return;
          if(marquee.repeatRemaining > 1){
            marquee.repeatRemaining--;
            updateRepeatCounterDisplay();
            doOnePass(); // repeat same item
          } else {
            marquee.cursor = nextIndex();
            marquee.repeatRemaining = marquee.repeatMax;
            updateRepeatCounterDisplay();
            updateMarqueeIndexDisplay(); // <-- update when advancing to next line
            doOnePass();
          }
        });
      };

      doOnePass();
    }

    function startMarqueeLoop(){
      marquee.running = true;
      updateABButtonLabel();
      showLineAt(marquee.cursor || 0);
    }

    function stopMarqueeLoop(){
      marquee.running = false;
      marquee.animToken++;
      // Stop any current transition cleanly
      const el = $('marqueeText');
      el.style.transition = 'none';
    }

    function updateMarqueeIndexDisplay(){
      const el = $('marqueeIndex');
      if(!el) return;
      const total = marquee.lines.length|0;
      if(total <= 1){
        el.style.display = 'none';
        return;
      }
      const idx = ((marquee.cursor % total) + total) % total; // safe 0..total-1
      el.textContent = `${idx+1} / ${total}`;
      el.style.display = 'block';
      // match marquee text color
      try{ el.style.color = getComputedStyle($('marqueeText')).color; }catch{}
    }

    async function getJPListForSlug(slug){
      try{
        if (DRIVER === 'idb') {
          const filename = filenameFromSlug(slug);
          const computed = (currentGroup && currentGroup !== '__base__') ? `${currentGroup}/${filename}` : filename;
          const stored   = idbPathBySlug.get(slug);
          const path     = stored || computed;

          const raw = await storage.readFile(path);
          const t   = await normalizeReadResult(raw);
          const pairs = parsePairs(t);
          return pairs.map(p=>p[0]).filter(Boolean);
        }
        if(!dirHandle) return [];
        const base = await getGroupDirHandle(currentGroup);
        const fh = await base.getFileHandle(filenameFromSlug(slug));
        const t = await readFileText(fh);
        const pairs = parsePairs(t);
        return pairs.map(p=>p[0]).filter(Boolean);
      }catch{
        return [];
      }
    }

    async function startMarqueeFromSelected(){
      const slugs = getSelectedSlugs();
      if(!slugs.length) return;

      marquee.caller = 'start';

      if(slugs.length === 1){
        marquee.lines = await getJPListForSlug(slugs[0]);
      }else{
        // Combine JP lines across all selected decks
        const all = [];
        for(const slug of slugs){
          try{
            const ps = await readDeckPairsForSlug(slug);
            for(const [jp] of ps){ if(jp) all.push(jp); }
          }catch{}
        }
        marquee.lines = all;
      }

      marquee.cursor = 0;
      if(!marquee.lines.length){ showToast('No JP lines'); return; }

      const multi = marqueeHasMultiple();
      ['prevLineBtn','nextLineBtn','abLoopBtn'].forEach(id=>$(id).style.display = multi ? '' : 'none');
      marquee.loop = { a:null, b:null, enabled:false, stage:0 };
      updateABButtonLabel();
      marquee.repeatRemaining = marquee.repeatMax;
      updateRepeatCounterDisplay();

      // show/hide index badge & set initial text
      const idxEl = $('marqueeIndex');
      if (idxEl) idxEl.style.display = multi ? 'block' : 'none';
      updateMarqueeIndexDisplay();

      showMarqueeScreen();
      // Hide repeat counter if only one line
      const repeatEl = $('marqueeRepeat');
      if (repeatEl) {
        repeatEl.style.display = marquee.lines.length > 1 ? 'block' : 'none';
      }
      startMarqueeLoop();
    }

    function startMarqueeFromSession(){
      if(!state.cards.length) return;
      marquee.caller = 'session';

      // We only want the JP string of the current card.
      // We can recover JP by checking promptSide:
      // If promptSide==='jp': current.q is JP
      // If promptSide==='en': current.a is JP
      const cur = state.cards[state.idx];
      const jp = (state.promptSide==='jp') ? cur.q : cur.a;
      marquee.lines = [jp].filter(Boolean);
      marquee.cursor = 0;
      if(!marquee.lines.length){ showToast('No JP text'); return; }
      const multi = marqueeHasMultiple();
      ['prevLineBtn','nextLineBtn','abLoopBtn'].forEach(id=>$(id).style.display = multi ? '' : 'none');
      marquee.loop = { a:null, b:null, enabled:false, stage:0 };
      updateABButtonLabel();
      marquee.repeatRemaining = marquee.repeatMax;
      updateRepeatCounterDisplay();
      showMarqueeScreen();
      // Hide repeat counter if only one line
      const repeatEl = $('marqueeRepeat');
      if (repeatEl) {
        repeatEl.style.display = marquee.lines.length > 1 ? 'block' : 'none';
      }
      startMarqueeLoop();
    }

    // Utils
    function slugify(name){
      name = String(name || '').trim();
      // Preserve a leading numeric prefix with a dot, e.g. "01." or "007."
      const m = name.match(/^\s*(\d+)\.\s*/);
      let prefix = '';
      if(m){
        prefix = m[1] + '.';                // keep exact digits + dot
        name = name.slice(m[0].length);     // remove prefix (incl. following spaces) from the remainder
      }
      // Slugify the remainder; allow dot characters; collapse spaces to underscores
      const rest = name.toLowerCase()
                       .replace(/[^\p{L}\p{N}\s._-]/gu,'')   // allow letters/numbers/space/._-
                       .trim()
                       .replace(/\s+/g,'_')
                       .replace(/_+/g,'_')
                       .replace(/^_+|_+$/g,'');
      return prefix ? (rest ? `${prefix}_${rest}` : `${prefix}`) : rest;
    }
    function titleCase(s){
      return s.toLowerCase().trim().split(/\s+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
    }
    // Truncate display string to avoid overflow
    function truncateString(s, max=15){
      s = String(s || '');
      return s.length > max ? s.slice(0, max) + '...' : s;
    }

    const PREFIX = 'sc_progress:';
    function keyForSlug(slug){ return PREFIX + slug; }
    function slugToNiceName(slug){ return titleCase(slug.replace(/[_-]+/g,' ')); }

    // Progress-only storage (localStorage)
    function loadProgress(slug){
      try{ return JSON.parse(localStorage.getItem(keyForSlug(slug))||'null'); }
      catch{ return null; }
    }
    function saveProgressObj(slug, obj){
      try{ localStorage.setItem(keyForSlug(slug), JSON.stringify(obj)); }catch{}
    }

    const DIFFICULT_KEY = 'sc_difficult_cards';
    function loadDifficult(){
      try{ return JSON.parse(localStorage.getItem(DIFFICULT_KEY)||'[]'); }catch{ return []; }
    }
    function saveDifficult(list){
      try{ localStorage.setItem(DIFFICULT_KEY, JSON.stringify(list)); }catch{}
    }
    function _normLine(s){
      // Trim, collapse ASCII + full-width spaces, unify whitespace
      return String(s||'')
        .replace(/[\u3000\s]+/g,' ') // collapse full-width & ascii spaces
        .trim();
    }
    function difficultKey(rec){
      return `${rec.slug||'(combined)'}@@${_normLine(rec.jp)}@@${_normLine(rec.en)}`;
    }

    function markCurrentAsDifficult(){
      if(!state.cards.length) return false;
      const c = state.cards[state.idx];
      const jp = (state.promptSide==='jp') ? c.q : c.a;
      const en = (state.promptSide==='jp') ? c.a : c.q;
      const rec = {
        slug: state.setSlug || '(combined)',
        setName: state.setName || '(Combined)',
        jp, en, ts: Date.now()
      };
      const list = loadDifficult();
      const key = difficultKey(rec);
      const seen = new Set(list.map(difficultKey));
      if(!seen.has(key)){
        list.push(rec);
        saveDifficult(list);
        return true; // added
      }
      return false; // already present
    }

    function removeCurrentCardFromSession(){
      if(!state.cards.length) return;
      state.cards.splice(state.idx,1);
      if(state.idx >= state.cards.length){ state.idx = Math.max(0, state.cards.length-1); }
      state.shown = false; state.done = (state.cards.length===0);
      if(state.done){
        $('promptArea').textContent='Done!';
        $('answerArea').textContent='Done!';
        $('progress').textContent='0/0';
        $('goBtn').textContent='Restart';
        cancelCardTimers();
      } else {
        updateHUD();
      }
    }

    // Review screen
    function showReviewScreen(){
      $('inputCard').style.display='none';
      $('sessionCard').style.display='none';
      $('marqueeCard').style.display='none';
      $('reviewCard').style.display='block';
      renderReviewList();
    }
    function hideReviewScreen(){
      $('reviewCard').style.display='none';
      $('inputCard').style.display='block';
    }
    function renderReviewList(){
      const list = loadDifficult();
      $('reviewCount').textContent = `Difficult: ${list.length}`;
      const box = $('reviewList');
      box.innerHTML = '';
      if(!list.length){ box.textContent = 'No difficult cards yet.'; return; }
      for(const rec of list){
        const div = document.createElement('div');
        div.className = 'reviewItem';
        const slug = document.createElement('div'); slug.className='slug'; slug.textContent = rec.setName ? `${rec.setName}` : `${rec.slug||''}`;
        const jp = document.createElement('div'); jp.className='jp'; jp.textContent = rec.jp||'';
        const en = document.createElement('div'); en.className='en'; en.textContent = rec.en||'';
        div.appendChild(slug); div.appendChild(jp); div.appendChild(en);
        box.appendChild(div);
      }
    }
    function clearReview(){ saveDifficult([]); renderReviewList(); showToast('Cleared'); }

    // Unnamed generator using existing files in the chosen folder
    async function nextUnnamed(){
      const files = await listDataFiles();
      const have = new Set(files.map(f=>slugFromFilename(f.name)));
      let n=1, slug;
      do { slug = slugify(`Unnamed ${n}`); n++; } while(have.has(slug));
      return { name: titleCase(slug.replace(/_/g,' ')), slug };
    }

    // Ensure slug is unique among existing files in the chosen folder
    async function ensureUniqueSlug(base){
      const files = await listDataFiles();
      const have = new Set(files.map(f=>slugFromFilename(f.name)));
      if(!have.has(base)) return base;
      let i = 2, candidate = `${base}_${i}`;
      while(have.has(candidate)){ i++; candidate = `${base}_${i}`; }
      return candidate;
    }

    // Parser ignores a first-line NAME header (case-insensitive)
    function parsePairs(text){
      const lines=text.split(/\r?\n/);
      let i=0;
      if(/^\s*NAME:\s*/i.test(lines[0]||'')){ i=1; }
      const pairs=[];
      for(; i<lines.length; ){
        const jp=(lines[i]??'').trim();
        const en=(lines[i+1]??'').trim();
        if(jp&&en){pairs.push([jp,en]);i+=2;}else{i++;}
        while(i<lines.length && !lines[i].trim()) i++;
      }
      return pairs;
    }

    function sanitizeHeaderName(raw){
      const s = String(raw||'').trim();
      // strip trailing counts like "(2 / 20)"
      return s.replace(/\s*\(\s*\d+\s*\/\s*\d+\s*\)\s*$/, '');
    }

    function headerNameFromTextarea(){
      const ta = $('pairs'); if(!ta) return '';
      const first = (ta.value.split(/\r?\n/,1)[0]||'');
      const m = first.match(/^\s*name\s*:\s*(.*)$/i);
      if(!m) return '';
      const cleaned = sanitizeHeaderName(m[1]);
      return cleaned.trim();
    }

    const state={cards:[],idx:0,shown:false,promptSide:'jp',done:false,setName:'',setSlug:''};
    // Viewer font sizing (applies to both panels, persists)
    const VIEW_FONT_KEY = 'sc_view_font_rem';
    const SELECTED_GROUP_KEY = 'sc_selected_group';
    const SELECTED_CARD_KEY  = 'sc_selected_card';
    let viewFontRem = parseFloat(localStorage.getItem(VIEW_FONT_KEY) || '2.0');
    function applyViewFont(){
      const v = Math.max(1.0, Math.min(4.0, viewFontRem));
      ['promptArea','answerArea'].forEach(id=> $(id).style.fontSize = v + 'rem');
      updateViewerLayout();
    }
    function bumpViewFont(delta){
      viewFontRem = Math.max(1.0, Math.min(4.0, +(viewFontRem + delta).toFixed(2)));
      localStorage.setItem(VIEW_FONT_KEY, String(viewFontRem));
      applyViewFont();
    }
    function updateViewerLayout(){
      const vb = document.querySelector('.viewerBox');
      if(!vb) return;
      const single = carMode ? (viewFontRem >= 2.2) : false; // never single in non-car
      vb.classList.toggle('single', single);
      vb.classList.toggle('showPrompt', single && !state.shown);
      vb.classList.toggle('showAnswer', single && state.shown);
    }

    // ===== Study Card Timer =====
    const TIMER_OPTIONS = [0,5,10,15,20,30,60];
    let timerIdx = parseInt(localStorage.getItem('sc_timer_idx') || '0', 10);
    if(!(timerIdx>=0 && timerIdx<TIMER_OPTIONS.length)) timerIdx = 0;
    function timerSeconds(){ return TIMER_OPTIONS[timerIdx]; }
    function updateTimerLabel(){
      const b = $('timerBtn');
      if (!b) return;
      if (paused && pausedRemainingMs > 0) {
        b.textContent = `${Math.max(0, Math.ceil(pausedRemainingMs / 1000))}s`;
      } else {
        b.textContent = `${timerSeconds()}s`;
      }
    }
    function cycleTimer(){
      timerIdx = (timerIdx+1) % TIMER_OPTIONS.length;
      localStorage.setItem('sc_timer_idx', String(timerIdx));
      updateTimerLabel();
      cancelCardTimers();
      if(sessionActive()) scheduleCardTimer();
      if (timerSeconds() === 0) {
        paused = false;
        setPauseLabel('Pause');
      }
      updatePauseButtonEnabled();
    }

    let revealTO=null, nextTO=null;
    let timerInterval=null; // interval for countdown label
    let timerEndAt=0;       // epoch ms when current phase ends

    // ---- Pause/Continue (car-mode only) ----
    let paused = false;
    let pausedRemainingMs = 0; // how much time left when paused

    function timerActive(){ return !!(revealTO || nextTO); }
    function cancelCardTimers(){
      if(revealTO){ clearTimeout(revealTO); revealTO=null; }
      if(nextTO){ clearTimeout(nextTO); nextTO=null; }
      if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
      timerEndAt = 0;
      // restore static label when not actively counting
      updateTimerLabel();
    }

    function startCountdown(ms){
      if(!$('timerBtn')) return;
      if(ms<=0){ updateTimerLabel(); return; }
      timerEndAt = Date.now() + ms;
      // draw immediately, then every 1s
      const draw = ()=>{
        const now = Date.now();
        const remain = Math.max(0, Math.ceil((timerEndAt - now)/1000));
        $('timerBtn').textContent = `${remain}s`;
        if(remain<=0 && timerInterval){ clearInterval(timerInterval); timerInterval=null; }
      };
      draw();
      if(timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(draw, 1000);
    }
    function scheduleCardTimer(){
      if (paused) { updateTimerLabel(); updatePauseButtonEnabled(); return; }
      cancelCardTimers();
      const secs = timerSeconds();
      if(!secs){ updateTimerLabel(); return; } // 0s: disabled
      const ms = secs*1000;

      if(!state.shown){ // waiting to reveal answer
        revealTO = setTimeout(()=>{ if(sessionActive()) go(); }, ms);
      } else { // answer visible -> move next
        nextTO = setTimeout(()=>{ if(sessionActive()) go(); }, ms);
      }
      startCountdown(ms);
      updatePauseButtonEnabled();
    }

    function updatePauseButtonEnabled() {
      const b = $('pauseBtn');
      if (!b) return;
      const enabled = (timerSeconds() > 0) && sessionActive() && carMode;
      b.disabled = !enabled;
    }

    function setPauseLabel(txt){
      const b = $('pauseBtn'); if(!b) return;
      // Fade out a touch, swap text, then fade back in
      b.classList.add('fading');
      setTimeout(()=>{
        b.textContent = txt;
        // toggle red style based on label
        if (txt === 'Continue') {
          b.classList.add('paused');
        } else {
          b.classList.remove('paused');
        }
        b.classList.remove('fading');
      }, 140);
    }

    function pauseSessionTimers() {
      if (paused) return;
      if (timerSeconds() === 0) return; // no-op if timer disabled
      // capture remaining time
      const remain = Math.max(0, timerEndAt ? (timerEndAt - Date.now()) : 0);
      pausedRemainingMs = remain;
      cancelCardTimers();
      paused = true;
      updateTimerLabel();
      setPauseLabel('Continue');
    }

    function resumeSessionTimers() {
      if (!paused) return;
      if (timerSeconds() === 0) {
        paused = false;
        setPauseLabel('Pause');
        return;
      }
      const ms = (pausedRemainingMs > 0) ? pausedRemainingMs : (timerSeconds() * 1000);
      paused = false;
      setPauseLabel('Pause');
      // schedule appropriate phase
      if (!state.shown) {
        revealTO = setTimeout(() => { if (sessionActive() && !paused) go(); }, ms);
      } else {
        nextTO = setTimeout(() => { if (sessionActive() && !paused) go(); }, ms);
      }
      startCountdown(ms);
    }

    function mapPairsToCards(pairs,side){return pairs.map(([jp,en])=>({q:side==='jp'?jp:en,a:side==='jp'?en:jp}));}

    async function startSession(){
      if (DRIVER === 'fs') {
        if(!dirHandle){ await chooseSentencesFolder(); if(!dirHandle) return; }
      }
      const userText = $('pairs').value.trim();
      const lines = userText.split(/\r?\n/);
      const m = (lines[0]||'').match(/^\s*name:\s*(.+)/i);
      const selectedSlugsMulti = getSelectedSlugs();

      // ---------- NEW: Multi-select flow ----------
      if (selectedSlugsMulti.length > 1){
        const { pairs } = await buildCombinedFromSelected(selectedSlugsMulti);
        if(!pairs.length){ alert('No pairs found'); return; }

        state.setName = `Combined (${selectedSlugsMulti.length})`;
        state.setSlug = ''; // transient session; do not persist progress per-file
        // honour saved promptSide? For combined, default to previous or 'jp'
        const saved = null;
        state.promptSide = 'jp';

        state.cards = mapPairsToCards(pairs, state.promptSide);
        state.idx = 0; state.shown = false; state.done = false;

        $('inputCard').style.display='none';
        $('sessionCard').style.display='block';
        $('actionBar').style.display='flex';
        document.body.classList.add('hasBar');
        updateHUD();
        updateTimerLabel();
        bindSessionGestures();
        updatePauseButtonEnabled();
        return;
      }
      // ---------- END NEW ----------
      
      // Resolve display name and slug.
      // IMPORTANT: If user selected an existing set, preserve its slug EXACTLY ...
      let displayName, slug;
      const selectedSlug = $('setSelect').value;

      if (selectedSlug) {
        // Existing file was chosen ‚Äî default: keep its slug unchanged.
        slug = selectedSlug;
        const baselineDisplay = titleCase(slugToNiceName(selectedSlug)); // e.g., "01. Cause Reason"

        if (m) {
          // Normalize header text: strip optional counts suffix like "(N / M)"
          const rawName = (m[1] || '').trim();
          const nameNoCounts = rawName.replace(/\s*\(\s*\d+\s*\/\s*\d+\s*\)\s*$/,'');
          displayName = titleCase(nameNoCounts);
          // Persist header without counts so we don't trigger clone behaviour
          lines[0] = `NAME: ${displayName}`;

          // Only clone to a new file if the user actually changed the NAME
          // compared to what this slug normally displays as (ignore counts)
          if (displayName !== baselineDisplay) {
            const proposed = slugify(displayName);            // canonical base (may remove dot)
            slug = await ensureUniqueSlug(proposed);          // ensure uniqueness when cloning
          }
        } else {
          // No header present ‚Äî derive display name from slug and insert header.
          displayName = baselineDisplay;
          lines.unshift(`NAME: ${displayName}`);
        }
      } else {
        // No existing file selected ‚Äî new or pasted content
        if (m) {
          // Normalize header and strip counts before slugifying
          const rawName = (m[1] || '').trim();
          const nameNoCounts = rawName.replace(/\s*\(\s*\d+\s*\/\s*\d+\s*\)\s*$/,'');
          displayName = titleCase(nameNoCounts);
          slug = slugify(displayName);
          lines[0] = `NAME: ${displayName}`;
        } else {
          // Completely new unnamed set
          const nu = await nextUnnamed();
          displayName = nu.name;
          slug = nu.slug;
          lines.unshift(`NAME: ${displayName}`);
        }
      }
      const textToSave = lines.join('\n');

      state.setName = displayName;
      state.setSlug = slug;

      // ---- Load saved progress FIRST so we honour saved promptSide ----
      const saved = loadProgress(slug);
      state.promptSide = (saved && saved.promptSide) ? saved.promptSide : 'jp';

      const raw = parsePairs(textToSave);
      if(raw.length===0){ alert('No pairs found'); return; }
      state.cards = mapPairsToCards(raw, state.promptSide);

      // Resume index/shown if present
      if(saved && saved.progress){
        const total = state.cards.length;
        state.idx = Math.max(0, Math.min(saved.progress.idx|0, total-1));
        state.shown = !!saved.progress.shown;
        state.done = false;
      } else {
        state.idx = 0; state.shown = false; state.done = false;
      }

      $('inputCard').style.display='none';
      $('sessionCard').style.display='block';
      $('actionBar').style.display='flex';
      document.body.classList.add('hasBar');
      updateHUD();
      updateTimerLabel();
      bindSessionGestures();
      updatePauseButtonEnabled();
      // refresh select from disk to ensure presence
      await populateSetSelectFromDir(slug);
    }

    function updateHUD(){
      const current=state.cards[state.idx];
      $('progress').textContent=`${Math.min(state.idx+1,state.cards.length)}/${state.cards.length}`;
      $('promptArea').textContent=current?.q??'';
      $('answerArea').textContent=current?.a??'';
      $('answerArea').style.opacity=state.shown?'1':'0.45';
      $('answerArea').style.filter=state.shown?'none':'blur(5px)';
      $('goBtn').textContent=state.shown?'Next':'Go';
      $('reverseBtn').textContent=state.promptSide==='jp'?'EN':'JP';
      scheduleCardTimer();
      updateViewerLayout();
    }

    function updateStartEnabled(){
      const ta = $('pairs');
      const slugs = getSelectedSlugs();
      const hasSet = slugs.length > 0;
      const hasText = ta.value.trim().length > 0;

      // Start/Scroll rules unchanged
      $('startBtn').disabled = !(hasSet || hasText);
      $('marqueeBtnStart').disabled = !hasSet; // Scroll-from-home needs at least one set

      // Save enabled when:
      // - NAME header exists (non-blank)
      // - textarea has any content
      const headerOk = !!headerNameFromTextarea();
      // Allow saving new decks from pasted text even with no Card selected
      const enableSave = headerOk && hasText;
      const sb = $('saveBtn');
      if(sb) sb.disabled = !enableSave;
    }

    function saveProgress(){
      if(!state.setSlug) return;
      const obj = {
        name: titleCase(state.setName||slugToNiceName(state.setSlug)),
        progress: { idx: state.idx, shown: state.shown },
        promptSide: state.promptSide,
        ts: Date.now()
      };
      saveProgressObj(state.setSlug, obj);
    }

    function go(){
      if(state.cards.length===0)return;
      if (paused) { paused = false; setPauseLabel('Pause'); }
      if(state.done){
        state.idx=0;state.shown=false;state.done=false;updateHUD();saveProgress();return;
      }
      if(!state.shown){
        state.shown=true;updateHUD();saveProgress();
        beepReveal();
      } else {
        state.idx++;
        if(state.idx>=state.cards.length){
          // End of deck: show "Done!" in BOTH panels and mark as done
          $('promptArea').textContent='Done!';
          $('answerArea').textContent='Done!';
          $('progress').textContent=`${state.cards.length} / ${state.cards.length}`;
          state.idx=state.cards.length-1;
          state.done=true;
          $('goBtn').textContent='Restart';
          saveProgress();
          // If a timer is configured (>0s), schedule auto-restart after countdown
          if (timerSeconds() > 0) {
            scheduleCardTimer();
          }
        } else {
          state.shown=false;updateHUD();saveProgress();
          beepNext();
        }
      }
    }

    function stepBack(){
      if(state.cards.length===0) return;
      if (paused) { paused = false; setPauseLabel('Pause'); }
      if(state.shown){
        state.shown=false; state.done=false; updateHUD(); saveProgress(); return;
      }
      if(state.idx<=0) return;
      state.idx--; state.shown=false; state.done=false; updateHUD(); saveProgress();
    }

    function reverseSides(){
      state.promptSide=state.promptSide==='jp'?'en':'jp';
      if (paused) { paused = false; setPauseLabel('Pause'); }
      for(const c of state.cards){const t=c.q;c.q=c.a;c.a=t;}
      state.shown=false;state.done=false;updateHUD();saveProgress();
    }

    function shuffleDeck(){
      if(!state.cards.length) return;
      if (paused) { paused = false; setPauseLabel('Pause'); }
      for(let i=state.cards.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [state.cards[i],state.cards[j]]=[state.cards[j],state.cards[i]];
      }
      state.idx=0; state.shown=false; state.done=false;
      updateHUD(); saveProgress();
      showToast('Shuffled!');
    }

    async function back(){
      if (paused) { paused = false; setPauseLabel('Pause'); }
      // Stop any timers
      cancelCardTimers();
      unbindSessionGestures();
      // Hide session UI, show home
      $('sessionCard').style.display='none';
      $('actionBar').style.display='none';
      document.body.classList.remove('hasBar');
      $('inputCard').style.display='block';

      // Re-enable card select if we had disabled it
      if (dirHandle) $('setSelect').disabled = false;

      // Keep state name/slug as-is; we only leave session mode
      state.done = false;

      // Ensure buttons reflect current state (enables Scroll, Save, etc.)
      updateStartEnabled();
    }

    // ===== Session swipe gestures (Pointer Events only) =====
    let unbindSwipe = null; // single unbind function

    function bindSessionGestures(){
      const targets = [ $('promptArea'), $('answerArea') ].filter(Boolean);
      if(!targets.length) return;
      unbindSessionGestures();

      const listeners = [];
      const attach = (el)=>{
        let sx=0, sy=0, t0=0, active=false, moved=false;
        const down = (ev)=>{ sx=ev.clientX; sy=ev.clientY; t0=Date.now(); active=true; moved=false; };
        const move = (ev)=>{ if(!active) return; moved=true; };
        const up = (ev)=>{
          if(!active) return; active=false;
          const dx = ev.clientX - sx, dy = ev.clientY - sy;
          const adx = Math.abs(dx), ady = Math.abs(dy);
          const dt  = Date.now() - t0;
          // thresholds tuned for mobile swipes
          if (!moved) return;
          if (Math.max(adx,ady) < 36 || dt > 700) return; // small/slow -> ignore
          if (adx <= ady) return; // vertical-dominant -> ignore
          if (dx > 0){
            // RIGHT: mark difficult, then remove from session
            const added = markCurrentAsDifficult();
            showToast(added ? 'Added to Difficult & removed' : 'Already added ‚Äî removed');
            cancelCardTimers();
            removeCurrentCardFromSession();
          } else {
            // LEFT: remove from session
            showToast('Removed from session');
            removeCurrentCardFromSession();
          }
        };
        el.addEventListener('pointerdown', down, {passive:true});
        el.addEventListener('pointermove', move, {passive:true});
        el.addEventListener('pointerup',   up,   {passive:true});
        listeners.push(()=>{ try{el.removeEventListener('pointerdown', down);}catch{} try{el.removeEventListener('pointermove', move);}catch{} try{el.removeEventListener('pointerup', up);}catch{} });
      };

      for(const el of targets){ attach(el); }
      unbindSwipe = ()=>{ for(const off of listeners){ try{off();}catch{} } };
    }

    function unbindSessionGestures(){
      try{ unbindSwipe && unbindSwipe(); }catch{}
      unbindSwipe = null;
    }


    function showToast(msg){
      const t=$('toast');
      t.textContent=msg;
      t.classList.add('show');
      clearTimeout(showToast._timer);
      showToast._timer=setTimeout(()=>t.classList.remove('show'), 1600);
    }

    // ----- Clipboard helper -----
    async function copyToClipboard(text){
      if(!text) return false;
      try{
        if(navigator.clipboard?.writeText){
          await navigator.clipboard.writeText(text);
          return true;
        }
      }catch{}
      // Fallback for older engines
      const ta = document.createElement('textarea');
      ta.value = text;
      ta.style.position = 'fixed';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.focus(); ta.select();
      let ok=false; try{ ok=document.execCommand('copy'); }catch{}
      document.body.removeChild(ta);
      return ok;
    }

    function formatNowStamp(){
      const d = new Date();
      const pad = (n)=> String(n).padStart(2,'0');
      const yyyy = d.getFullYear();
      const mm   = pad(d.getMonth()+1);
      const dd   = pad(d.getDate());
      const hh   = pad(d.getHours());
      const mi   = pad(d.getMinutes());
      return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
    }

    async function exportReview(){
      const list = loadDifficult();
      if(!list || !list.length){ showToast('No difficult cards'); return; }
      // Build Study Cards format text
      const header = `Name: Reviews ${formatNowStamp()}`;
      const body = list.map(r=>`${r.jp || ''}\n${r.en || ''}`).join('\n\n');
      const txt = `${header}\n\n${body}\n`;
      const ok = await copyToClipboard(txt);
      showToast(ok ? `Copied ${list.length} pairs` : 'Copy failed');
    }

    async function readClipboardText(){
      try{
        if(navigator.clipboard?.readText){
          const t = await navigator.clipboard.readText();
          return t || '';
        }
      }catch{}
      return '';
    }

    function ensureNameHeader(text){
      text = String(text||'');
      // strip leading whitespace
      text = text.replace(/^\s+/, '');
      // already has NAME header?
      if(/^\s*name\s*:/i.test(text)){
        // normalize to exactly one blank line after header
        return text.replace(/^(NAME:.*?)(\r?\n\s*)+?/im, '$1\n\n');
      }
      return `NAME: New Deck\n\n${text}`;
    }

    async function newDeckFromClipboard(){
      // Build from Difficult list (no clipboard needed)
      const list = loadDifficult();
      if(!list || !list.length){ showToast('No difficult cards'); return; }

      const header = `NAME: Reviews ${formatNowStamp()}`;
      const body = list.map(r=>`${r.jp||''}\n${r.en||''}`).join('\n\n');
      const txt = `${header}\n\n${body}\n`;

      // Go to Home page
      $('reviewCard').style.display='none';
      $('sessionCard').style.display='none';
      $('marqueeCard').style.display='none';
      $('inputCard').style.display='block';
      document.body.classList.remove('hasBar');

      // Select <base> group if groups visible
      const gsel = $('groupSelect');
      if(gsel && !gsel.disabled){
        gsel.value = '__base__';
        currentGroup = '__base__';
        try{ localStorage.setItem('sc_selected_group', currentGroup); }catch{}
        await populateSetSelectFromDir('');
      }

      // Clear Card selection and populate textarea
      const ssel = $('setSelect');
      if(ssel){ ssel.value = ''; }
      $('pairs').value = txt;
      updateStartEnabled();
      showToast(`Loaded ${list.length} pairs`);
      $('pairs').focus();
    }
  
    function showBusy(msg){
      const b=$('busy'); const m=$('busyMsg');
      if(m) m.textContent = msg || 'Working‚Ä¶';
      if(b) b.style.display='flex';
    }
    function hideBusy(){ const b=$('busy'); if(b) b.style.display='none'; }

    function sessionActive(){ return $('sessionCard').style.display!=='none'; }
    
    document.addEventListener('keydown', (e)=>{
      if(!sessionActive()) return;
      const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
      if(tag==='input' || tag==='textarea' || document.activeElement.isContentEditable) return;

      if(e.key==='ArrowRight'){ e.preventDefault(); go(); }
      else if(e.key==='ArrowLeft'){ e.preventDefault(); stepBack(); }
      else if(e.key==='r' || e.key==='R'){ e.preventDefault(); reverseSides(); }
      else if(e.key==='s' || e.key==='S'){ e.preventDefault(); shuffleDeck(); }
    });
    
    $('pairs').addEventListener('input', updateStartEnabled);
    $('pairs').addEventListener('focus', updateStartEnabled);
    $('pairs').addEventListener('blur',  updateStartEnabled);

    // highlight the japanese text to simplify opening in 
    // phone's Translation service
    function selectJapanese(){
      if(!sessionActive()) return;
      const el = state.promptSide==='jp' ? $('promptArea') : $('answerArea');
      try{
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        el.focus?.();
        el.click?.(); // harmless; some UIs like it
      }catch(err){ /* ignore */ }
    }

    $('startBtn').onclick = (e)=>{ ensureAudio(); startSession(e); };
    $('goBtn').onclick=()=>{ ensureAudio(); cancelCardTimers(); go(); };
    $('backStepBtn').onclick=()=>{ cancelCardTimers(); stepBack(); };
    $('reverseBtn').onclick=()=>{ cancelCardTimers(); reverseSides(); };
    $('shuffleTopBtn').onclick = ()=>{ cancelCardTimers(); shuffleDeck(); scheduleCardTimer(); };
    $('selectBtn').onclick = ()=>{ cancelCardTimers(); selectJapanese(); };
    $('backBtnTop').onclick=back;
    $('switchFolderBtn').onclick = () => { chooseSentencesFolder();};
    $('reconnectFolderBtn').onclick = () => { ensureFolderAccessInteractive();};
    $('pauseBtn').onclick = () => {
      if (timerSeconds() === 0) return; // no-op when timer disabled
      if (paused) resumeSessionTimers();
      else pauseSessionTimers();
    };

    $('syncLibraryBtn').onclick = async () => {
      if (DRIVER === 'idb') {
        showBusy('Downloading library‚Ä¶');
        try{
          await storage.init();
          const r = await storage.syncFromManifest('library/index.json');
          showToast(`Synced: ${r.wrote} files${r.errors?`, ${r.errors} errors`:''}`);
          // Refresh Groups & Cards from IDB
          await populateGroupSelect();
          await populateSetSelectFromDir('');
        }catch(e){
          console.warn(e);
          showToast('IDB sync failed');
        } finally {
          hideBusy();
        }
        return;
      }
      // FS mode
      syncLibraryIntoFolder();
    };

    $('marqueeBtnStart').onclick = startMarqueeFromSelected;
    $('carModeBtn').onclick = () => {
      setCarMode(!carMode);
    };
    // Bind Save with addEventListener to guarantee firing and log the event
    $('saveBtn').addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      saveCurrentTextareaToFile();
      setTimeout(updateStartEnabled, 0);
    });

    async function normalizeReadResult(v){
      if (typeof v === 'string') return v;
      if (v && typeof v.text === 'string') return v.text;
      return ''; // treat anything else as empty
    }

    async function loadSelectedCardsIntoTextarea(){
      const slugs = getSelectedSlugs();

      // Nothing selected
      if (!slugs.length){
        $('pairs').value = '';
        updateStartEnabled();
        return;
      }

      // Multi-select ‚Üí combine
      if (slugs.length > 1){
        const { text } = await buildCombinedFromSelected(slugs);
        $('pairs').value = text;
        updateStartEnabled();
        return;
      }

      // Single selection ‚Üí load raw text from storage
      const slug = slugs[0];
      const filename = filenameFromSlug(slug);

      let text = '';
      try{
        if (DRIVER === 'idb'){
          // Prefer exact path from IDB listing
          const stored = idbPathBySlug.get(slug);
          const computed = (currentGroup && currentGroup !== '__base__') ? `${currentGroup}/${filename}` : filename;
          const path = stored || computed;
          const raw = await storage.readFile(path);
          text = await normalizeReadResult(raw);
        } else {
          const base = await getGroupDirHandle(currentGroup);
          const fh = await base.getFileHandle(filename);
          text = await readFileText(fh);
        }
      }catch(e){
        alert('Failed to read file. Did it move or get renamed?');
        console.warn('[read]', e);
        $('pairs').value = '';
        updateStartEnabled();
        return;
      }

      // Ensure a NAME header exists; if not, synthesize from slug
      if (!/^\s*name\s*:/i.test(text)) {
        const display = titleCase(slugToNiceName(slug));
        text = `NAME: ${display}\n\n${text}`;
      }

      $('pairs').value = text;
      updateStartEnabled();
    }
    // Bind the loader
    $('setSelect').addEventListener('change', loadSelectedCardsIntoTextarea);
    $('marqueeBtnSession').onclick = startMarqueeFromSession;
    $('exitMarqueeBtn').onclick = () => { stopMarqueeLoop(); hideMarqueeScreen(); };
    $('fontUpBtn').onclick = () => setMarqueeFont(marquee.fontPx + 4);
    $('fontDownBtn').onclick = () => setMarqueeFont(marquee.fontPx - 4);
    $('speedUpBtn').onclick = () => { setMarqueeSpeed(marquee.pxPerSec + 20); restartMarqueeWithNewSpeed(); };
    $('speedDownBtn').onclick = () => { setMarqueeSpeed(marquee.pxPerSec - 20); restartMarqueeWithNewSpeed(); };
    // Marquee repeat counter
    $('marqueeRepeat').onclick = cycleRepeatMax;

    $('reviewBtn').onclick = showReviewScreen;
    $('reviewBackBtn').onclick = hideReviewScreen;
    $('reviewClearBtn').onclick = clearReview;
    $('reviewExportBtn').onclick = exportReview;
    $('reviewNewDeckBtn').onclick = newDeckFromClipboard;

    $('timerBtn').onclick = cycleTimer;
    updateTimerLabel();
    // Marquee navigation and A/B loop controls
    $('prevLineBtn').onclick = ()=>{ if(!marquee.lines.length) return; stopMarqueeLoop(); marquee.running = true; showLineAt(prevIndex()); };
    $('nextLineBtn').onclick = ()=>{ if(!marquee.lines.length) return; stopMarqueeLoop(); marquee.running = true; showLineAt(nextIndex()); };
    $('abLoopBtn').onclick = ()=>{
      if(!marqueeHasMultiple()) return;
      const st = marquee.loop.stage % 3;
      const cur = currentIndex();
      if(st===0){
        marquee.loop.a = cur; marquee.loop.stage = 1; showToast('A set');
      } else if(st===1){
        marquee.loop.b = cur; normalizeRange(); marquee.loop.enabled = true; marquee.loop.stage = 2; showToast('Loop A‚ÄìB');
        // If current is outside [A,B], jump to A to respect the new loop immediately
        const n = marquee.lines.length; if(n){
          const a = marquee.loop.a % n, b = marquee.loop.b % n;
          if(!(a <= marquee.cursor && marquee.cursor <= b)){
            stopMarqueeLoop(); marquee.running = true; showLineAt(a);
            updateABButtonLabel(); return;
          }
        }
      } else {
        marquee.loop = { a:null, b:null, enabled:false, stage:0 }; showToast('Loop reset');
      }
      updateABButtonLabel();
    };

    $('groupSelect').onchange = async function(){
      currentGroup = this.value || BASE_GROUP;
      try{ localStorage.setItem(SELECTED_GROUP_KEY, currentGroup); }catch{}
      try{ localStorage.removeItem(SELECTED_CARD_KEY); }catch{}  // clear stale card
      await populateSetSelectFromDir('');
      $('pairs').value = '';
      updateStartEnabled();
    };

    // Tap panels to adjust font: Prompt = bigger, Answer = smaller
    $('promptArea').addEventListener('click', ()=>{ bumpViewFont(0.2); showToast(`Font ${viewFontRem.toFixed(1)}rem`); });
    $('answerArea').addEventListener('click', ()=>{ bumpViewFont(-0.2); showToast(`Font ${viewFontRem.toFixed(1)}rem`); });

    // Initialize stored values (in case user never opened Marquee yet)
    setMarqueeFont(marquee.fontPx);
    setMarqueeSpeed(marquee.pxPerSec);

    function normalizeDeckTop(text, defaultName = "Example", setsCount = null, pairCount = null) {
      // 1) strip all leading whitespace/newlines
      text = String(text || '').replace(/^\s+/, "");

      // 2) capture/ensure NAME header (case-insensitive)
      const m = text.match(/^(?:NAME\s*:\s*)([^\r\n]*)/im);
      let name;
      if (m) {
        name = (m[1] || '').trim() || defaultName;
        text = text.replace(/^(?:NAME\s*:\s*)(.*)/im, `NAME: ${name}`);
      } else {
        name = defaultName;
        text = `NAME: ${name}\n\n` + text;
      }

      // 3) normalize to exactly ONE empty line after the header
      text = text.replace(/^(NAME:.*?)(\r?\n\s*)+/, "$1\n\n");

      // 4) if counts provided, rewrite header to include (sets / pairs)
      if (setsCount != null && pairCount != null) {
        text = text.replace(/^NAME:\s*.*$/m, `NAME: ${name} (${setsCount} / ${pairCount})`);
      }

      return text;
    }

    // Delete selected set
    $('deleteSetBtn').onclick = async function(){
      const slug=$('setSelect').value;
      if(!slug){ return; }
      try{ localStorage.removeItem(keyForSlug(slug)); }catch{}
      showToast(`Cleared saved state for: ${slugToNiceName(slug)}`);
    };

    (async function init(){
      $('setSelect').disabled = true;

      if (DRIVER === 'idb') {
        try{
          await storage.init();
          // First visit? Pull library into IDB.
          // (You can skip auto-sync if you prefer manual-only.)
          try{
            await storage.syncFromManifest('library/index.json');
          }catch(e){
            console.warn('[idb] initial sync failed', e);
          }
          await populateGroupSelect();
          await populateSetSelectFromDir('');
          showToast('IDB mode ready');
        }catch(e){
          console.warn(e);
          showToast('IDB init failed');
        }
        updateStartEnabled();
        setCarMode(false);
        applyViewFont();
        updateViewerLayout();
        return;
      }

      try{
        const h = await idbGet('sentencesDir');
        if(h){
          dirHandle = h;
          const q = await dirHandle.queryPermission({ mode:'readwrite' });
          if(q==='granted'){
            $('setSelect').disabled = false;
            await populateGroupSelect();

            // Restore previously selected group (if it exists)
            try{
              const savedGroup = localStorage.getItem(SELECTED_GROUP_KEY);
              if(savedGroup){
                const sel = $('groupSelect');
                if([...sel.options].some(o=>o.value===savedGroup)){
                  sel.value = savedGroup;
                  currentGroup = savedGroup;
                } else {
                  currentGroup = BASE_GROUP;
                  sel.value = BASE_GROUP;
                }
              }
            }catch{}

            await populateSetSelectFromDir();

            // Restore previously selected card (if it exists in this group)
            try{
              const savedCard = localStorage.getItem(SELECTED_CARD_KEY);
              if(savedCard){
                const sel = $('setSelect');
                if([...sel.options].some(o=>o.value===savedCard)){
                  sel.value = savedCard;
                  // Load its content into textarea (same logic as onchange)
                  const base = await getGroupDirHandle(currentGroup);
                  const fh = await base.getFileHandle(filenameFromSlug(savedCard));
                  let t = await readFileText(fh);
                  const name = titleCase(slugToNiceName(savedCard));
                  const pairs = parsePairs(t);
                  t = normalizeDeckTop(t, name, 1, pairs.length);
                  $('pairs').value = t;
                } else {
                  try{ localStorage.removeItem(SELECTED_CARD_KEY); }catch{}
                }
              }
            }catch{}

            updateStartEnabled();
            showToast('Folder restored');
          } else {
            // On mobile, permission prompts often require a user gesture
            showToast('Tap üîå to reconnect folder');
          }
          updateStartEnabled();
        }
      }catch(err){ /* ignore */ }
      // Default to non-car mode each launch (not persisted)
      setCarMode(false);
      applyViewFont();
      updateViewerLayout();
    })();
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(console.error);
      });
    }
  </script>
</body>
