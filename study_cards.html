<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#0b0f14">
  
  <title>Study Cards</title>
  <style>
    :root{ --bar-h: 76px; }
    body{font-family:sans-serif;background:#0b0f14;color:#3dba50;margin:0}
    
    .wrap{ padding:1rem; }
    .hasBar .wrap{
      padding-bottom: calc(var(--bar-h) + env(safe-area-inset-bottom, 0px));
    }

    textarea{width:100%;min-height:200px;box-sizing:border-box;}
    button{margin:0.25rem;padding:0.6rem 1.1rem;border-radius:12px;border:1px solid #334155;background:#1f2937;color:#facc15;cursor:pointer}
    button:hover{filter:brightness(1.08)}
    /* Disabled buttons look clearly inactive */
    button:disabled{
      background:#111827;          /* darker gray */
      color:#94a3b8;               /* muted text */
      border-color:#263241;        /* dim border */
      opacity:.65;
      cursor:not-allowed;
      filter:none;                 /* cancel hover brightening */
    }
    button:disabled:hover{ filter:none; }
    .iconBtn{padding:0.45rem 0.6rem; line-height:1; border-radius:10px}
    .card{border:1px solid #333;padding:1rem;margin:1rem;border-radius:12px;background:#121922;box-sizing:border-box}
    .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center}
    /* Top controls (session header) */
    .topBtn{
      margin: 0.15rem;
      padding: 0.6rem 1.0rem;
      border-radius: 12px;
      border: 2px solid #f3a404a3;
      background: #1f2937;
      color: #facc15;
      cursor: pointer;
    }
    .viewerBox{display:grid;gap:10px}
    .viewerBox .viewerPanel{
      height:28vh;min-height:28vh;max-height:28vh;
      background:#0f1722;border:1px solid #243244;border-radius:12px;
      padding:12px;font-size:2.0rem;line-height:1.6;width:100%;box-sizing:border-box;
      white-space:pre-wrap;user-select:text;overflow:auto;
    }
    #promptArea{color:#a3e635;}
    #answerArea{color:#facc15;}

    .bar{position:fixed;left:0;right:0;bottom:0;height:var(--bar-h);
      display:flex;align-items:center;justify-content:flex-end;gap:.4rem;
      padding:0.6rem max(0.8rem, env(safe-area-inset-right));
      padding-bottom:calc(0.6rem + env(safe-area-inset-bottom, 0px));
      background:linear-gradient(180deg,rgba(11,15,20,.0) 0%,#0b0f14 12%,#0b0f14 100%);
      border-top:1px solid #1f2a36;box-sizing:border-box}
    .bar .go{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#3fb950;color:#06200c;border:1px solid #46c35f;min-width:85px;text-align:center}
    .bar .back{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#38bdf8;color:#042635;border:1px solid #7dd3fc}
    .bar .scroll{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#facc15;color:#1f1300;border:1px solid #fde68a}
    .bar .select{font-size:1.0rem;padding:0.9rem 1.1rem;border-radius:16px;background:#fb923c;color:#1f1205;border:1px solid #fdba74}
    .bar .go:active,.bar .back:active,.bar .scroll:active{transform:translateY(1px)}
    .bar .aux{background:#1f2937}

    h1{margin:1rem}

    /* Saved sets label */
    label[for="setSelect"], .sectionLabel{ color:#facc15; font-weight:bold; }

    .inline-group{display:flex;align-items:center;gap:.4rem;flex-wrap:wrap}

    /* Hint paragraph colour */
    .hint{ color:#3dba5073; }
    select:disabled{ opacity:.55; filter:saturate(.6); }

    /* Blocking busy overlay */
    .modalBackdrop{position:fixed;inset:0;background:rgba(2,6,12,.72);display:none;align-items:center;justify-content:center;z-index:9999}
    .modalBox{background:#0f1722;border:1px solid #334155;border-radius:14px;padding:1rem 1.2rem;color:#fefce8;box-shadow:0 10px 28px rgba(0,0,0,.45);min-width:240px;text-align:center}
    .modalBox .spinner{display:inline-block;width:1em;height:1em;border:.18em solid #334155;border-top-color:#3fb950;border-radius:50%;animation:spin 1s linear infinite;margin-right:.5rem;vertical-align:-.14em}
    @keyframes spin{to{transform:rotate(360deg)}}

    /* Toast */
    .toast{
      position:fixed; left:50%; transform:translateX(-50%) translateY(6px);
      bottom:calc(var(--bar-h) + 16px);
      background:#1f2937; color:#fefce8; border:1px solid #334155;
      padding:.55rem .8rem; border-radius:12px; font-size:.95rem;
      opacity:0; pointer-events:none; transition:opacity .18s, transform .18s;
      box-shadow:0 6px 20px rgba(0,0,0,.35);
    }
    .toast.show{ opacity:1; transform:translateX(-50%) translateY(0); }

    /* ===== Marquee mode ===== */
    .marqueeWrap{display:flex;flex-direction:column;height:100vh;padding:1rem;box-sizing:border-box}
    #marqueeViewport{flex:2;min-height:66vh;background:#0f1722;border:1px solid #243244;border-radius:12px;overflow:hidden;display:flex;align-items:center}
    #marqueeText{white-space:nowrap;will-change:transform;display:inline-block;padding:0 2rem;font-weight:600;color:#facc15}
    .marqueeControls{flex:1;display:flex;gap:.5rem;align-items:center;justify-content:center}
    .ctrlBtn{font-size:1.15rem;padding:0.85rem 1.05rem;border-radius:14px;background:#1f2937;color:#fefce8;border:1px solid #334155}
    .ctrlBtn.scroll{background:#facc15;color:#1f1300;border:1px solid #fde68a}

    /* Marquee fullscreen overlay */
    #marqueeCard.fullscreen{ position:fixed; inset:0; margin:0; border-radius:0; padding:0; z-index:1000; }
    /* Keep control buttons inside and wrap on small screens */
    .marqueeControls{ flex-wrap:wrap; padding:0 1rem 1rem; box-sizing:border-box }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="inputCard" class="card">
      <h1 id="headerTitle">Study Cards</h1>
      <p class="hint">Use üìÅ to select a folder to store sentence files.<br>
        Use üîå to reconnect folder.<br>
        Grant permissions when prompted.<br>
        Use üîÑ to get the latest sentence files.
      </p>

      <!-- Library controls -->
      <div class="inline-group">
        <span class="sectionLabel" aria-hidden="true">Library:</span>
        <button id="switchFolderBtn" class="iconBtn" title="Pick a different folder" aria-label="Pick a different folder">üìÅ</button>
        <button id="reconnectFolderBtn" class="iconBtn" title="Reconnect stored folder" aria-label="Reconnect stored folder">üîå</button>
        <button id="syncLibraryBtn" class="iconBtn" title="Sync library into folder" aria-label="Sync library into folder">üîÑ</button>
      </div>

      <!-- Sets controls -->
      <div class="inline-group">
        <label for="setSelect">Sets:</label>
        <select id="setSelect" disabled>
          <option value="">(none)</option>
        </select>
        <button id="deleteSetBtn" class="iconBtn" title="Delete saved state (keeps file)" aria-label="Delete saved state (keeps file)">üóë</button>
        <button id="deleteFileBtn" class="iconBtn" title="Delete set file (destructive)" aria-label="Delete set file">üíÄ</button>
      </div>

      <br>

      <textarea id="pairs" placeholder="NAME: Example

„Åì„Çì„Å´„Å°„ÅØ
Hello

„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô
Thank you

„Åô„Åø„Åæ„Åõ„Çì
Excuse me"></textarea><br>

      <button id="startBtn" disabled>Start session</button>
      <button id="marqueeBtnStart" disabled>Scroll</button>
    </div>

    <div id="sessionCard" class="card" style="display:none">
      <div class="row" style="justify-content:space-between; margin-bottom:.5rem">
        <div id="progress"></div>
        <div>
          <button id="reverseBtn" class="topBtn" title="Flip JP‚ÜîEN for this session">EN‚ÜíJP</button>
          <button id="backBtnTop" class="topBtn">New</button>
          <button id="shuffleTopBtn" class="topBtn">Mix</button>
          <button id="timerBtn" class="topBtn" title="Auto reveal/advance">0s</button>
        </div>
      </div>

      <div class="viewerBox">
        <div id="promptArea" class="viewerPanel" role="textbox" aria-readonly="true" tabindex="0"></div>
        <div id="answerArea" class="viewerPanel" role="textbox" aria-readonly="true" tabindex="0"></div>
      </div>

      <div class="bar" id="actionBar" style="display:none">
        <button id="marqueeBtnSession" class="scroll">Scroll</button>
        <button id="selectBtn" class="select">Select</button>
        <button id="backStepBtn" class="back">Back</button>
        <button id="goBtn" class="go">Go</button>
      </div>

    </div>

    <div id="marqueeCard" class="card" style="display:none; padding:0;">
      <div class="marqueeWrap">
        <div id="marqueeViewport">
          <div id="marqueeText" style="font-size:72px;"></div>
        </div>
        <div class="marqueeControls">
          <button id="fontDownBtn" class="ctrlBtn">A‚àí</button>
          <button id="fontUpBtn" class="ctrlBtn">A+</button>
          <button id="speedDownBtn" class="ctrlBtn">‚¨áÔ∏è</button>
          <button id="speedUpBtn" class="ctrlBtn">‚¨ÜÔ∏è</button>
          <button id="prevLineBtn" class="ctrlBtn" title="Previous">‚óÄ</button>
          <button id="nextLineBtn" class="ctrlBtn" title="Next">‚ñ∂</button>
          <button id="abLoopBtn" class="ctrlBtn" title="Set A / Set B / Loop / Reset">a</button>
          <button id="exitMarqueeBtn" class="ctrlBtn scroll">Exit</button>
        </div>
      </div>
    </div>

  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <div id="busy" class="modalBackdrop" role="dialog" aria-live="polite" aria-modal="true">
    <div class="modalBox"><span class="spinner" aria-hidden="true"></span><span id="busyMsg">Downloading‚Ä¶</span></div>
  </div>

  <script>
    const $=id=>document.getElementById(id);

    // --- File System Access API (Chrome) ---
    let dirHandle = null;           // chosen /sentences directory
    const EXT = '.data';            // deck file extension

    // Library sync configuration (repo-hosted files)
    const LIB_INDEX_URL = 'library/index.json';  // GH Pages path to library manifest
    const LIB_TARGET_SUBDIR = '';                // write library decks into the chosen folder root
    const SYNC_POLICY = 'overwriteChanged';      // 'addNewOnly' | 'overwriteChanged' | 'forceOverwriteAll'

    function slugFromFilename(name){
      return name.replace(/\.[^.]+$/, '');
    }
    function filenameFromSlug(slug){
      return `${slug}${EXT}`;
    }

    async function chooseSentencesFolder(){
      try{
        dirHandle = await window.showDirectoryPicker({ mode:'readwrite' });
        await navigator.storage?.persist?.();   // request persistent storage
        await idbSet('sentencesDir', dirHandle);
        $('setSelect').disabled = false;
        await populateSetSelectFromDir();
        showToast('Folder selected');
      }catch(err){
        // user cancelled; keep disabled state
      }
    }

    async function listDataFiles(){
      if(!dirHandle) return [];
      const files=[];
      for await (const [name, handle] of dirHandle.entries()){
        if(handle.kind==='file' && name.toLowerCase().endsWith(EXT)){
          files.push({ name, handle });
        }
      }
      const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
      files.sort((a,b)=>coll.compare(a.name,b.name));
      return files;
    }

    async function readFileText(fileHandle){
      const file = await fileHandle.getFile();
      return await file.text();
    }

    async function writeFileText(slug, text){
      if(!dirHandle) throw new Error('No folder selected');
      const fh = await dirHandle.getFileHandle(filenameFromSlug(slug), { create:true });
      const ws = await fh.createWritable();
      await ws.write(text);
      await ws.close();
    }

    async function saveViaPickerFallback(filename, text){
      if(!window.showSaveFilePicker) return false;
      try{
        const fh = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{ description: 'Sentence data', accept: { 'text/plain': ['.data', '.txt'] } }]
        });
        const ws = await fh.createWritable();
        await ws.write(text);
        await ws.close();
        showToast('Saved via picker');
        return true;
      }catch{
        return false;
      }
    }

    // Attempt to restore access via user gesture; fall back to picking
    async function ensureFolderAccessInteractive(){
      try{
        if(!dirHandle){
          const h = await idbGet('sentencesDir');
          if(h) dirHandle = h;
        }
        if(dirHandle){
          let q = await dirHandle.queryPermission({ mode:'readwrite' });
          if(q !== 'granted'){
            // requestPermission must be called in a user gesture (button tap)
            q = await dirHandle.requestPermission({ mode:'readwrite' });
          }
          if(q === 'granted'){
            $('setSelect').disabled = false;
            await populateSetSelectFromDir();
            showToast('Folder reconnected');
            return true;
          }
        }
        // If we get here, either no handle or permission denied ‚Äî pick anew
        await chooseSentencesFolder();
        return !!dirHandle;
      }catch(err){ return false; }
    }

    // --- Network & file helpers for Library sync ---
    async function fetchTextScoped(path){
      const url = new URL(path, location.href).toString();
      const res = await fetch(url, { cache: 'no-cache' });
      if(!res.ok) throw new Error(`Fetch ${path} ${res.status}`);
      return await res.text();
    }
    async function fetchJSONScoped(path){
      return JSON.parse(await fetchTextScoped(path));
    }
    async function ensureSubdir(dirHandle, name){
      return name ? await dirHandle.getDirectoryHandle(name, { create:true }) : dirHandle;
    }
    async function fileExists(dir, filename){
      try { await dir.getFileHandle(filename); return true; }
      catch { return false; }
    }
    async function readFileIfExists(dir, filename){
      try { const fh = await dir.getFileHandle(filename); const f = await fh.getFile(); return await f.text(); }
      catch { return null; }
    }

    // --- Sync Library (repo) into chosen folder ---
    async function syncLibraryIntoFolder(){
        showBusy('Downloading sentences...');
        showToast('Downloading sentences...');
        try{
          if(!dirHandle){
          const picked = await chooseSentencesFolder();
          if(!dirHandle) return; // user cancelled
        }
        let index;
        try {
          index = await fetchJSONScoped(LIB_INDEX_URL);
        } catch (e) {
          showToast('Library index not available');
          return;
        }
        const files = index.files || [];
        if(!files.length){ showToast('Library is empty'); return; }

        const targetDir = await ensureSubdir(dirHandle, LIB_TARGET_SUBDIR);
        let wrote = 0, skipped = 0, errors = 0;

        for(const item of files){
          const rel = typeof item === 'string' ? item : (item.path || item.file || item.name);
          if(!rel) continue;
          try{
            const name = rel.split('/').pop();
            const libText = await fetchTextScoped('library/' + rel.replace(/^library\//,''));

            if(SYNC_POLICY === 'addNewOnly'){
              if(await fileExists(targetDir, name)){ skipped++; continue; }
              const fh = await targetDir.getFileHandle(name, { create:true });
              const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++; continue;
            }

            if(SYNC_POLICY === 'overwriteChanged'){
              const current = await readFileIfExists(targetDir, name);
              if(current !== null && current === libText){ skipped++; continue; }
              const fh = await targetDir.getFileHandle(name, { create:true });
              const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++; continue;
            }

            // 'forceOverwriteAll'
            const fh = await targetDir.getFileHandle(name, { create:true });
            const ws = await fh.createWritable(); await ws.write(libText); await ws.close(); wrote++;
          }catch(err){
            console.warn('Sync fail', rel, err);
            errors++;
          }
        }

        await populateSetSelectFromDir();
        showToast(`Library sync: ${wrote} wrote, ${skipped} skipped${errors?`, ${errors} errors`:''}`);
      } finally {
        hideBusy();
      }
    }

    // --- IndexedDB for persisting FileSystemHandles ---
    const DB_NAME='sc_fs_db', STORE='handles';
    function idbOpen(){
      return new Promise((resolve, reject)=>{
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e)=>{ e.target.result.createObjectStore(STORE); };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      });
    }
    async function idbSet(key, value){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readwrite');
        tx.oncomplete=()=>resolve();
        tx.onerror=()=>reject(tx.error);
        tx.objectStore(STORE).put(value, key);
      });
    }
    async function idbGet(key){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readonly');
        const req = tx.objectStore(STORE).get(key);
        req.onsuccess=()=>resolve(req.result);
        req.onerror=()=>reject(req.error);
      });
    }
    async function idbDel(key){
      const db = await idbOpen();
      return new Promise((resolve, reject)=>{
        const tx = db.transaction(STORE, 'readwrite');
        tx.oncomplete=()=>resolve();
        tx.onerror=()=>reject(tx.error);
        tx.objectStore(STORE).delete(key);
      });
    }

    async function populateSetSelectFromDir(selectedSlug=''){
      const sel=$('setSelect');
      const current = sel.value;
      sel.innerHTML='<option value="">(none)</option>';
      const files = await listDataFiles();
      const items = files.map(f=>{ const slug = slugFromFilename(f.name); return { slug, display: titleCase(slugToNiceName(slug)) }; });
      const coll = new Intl.Collator(undefined, { numeric:true, sensitivity:'base' });
      items.sort((a,b)=>coll.compare(a.display,b.display)||a.slug.localeCompare(b.slug));
      for (const {slug, display} of items){
        const opt = document.createElement('option');
        opt.value = slug;
        opt.textContent = truncateString(display); // label shown to user
        opt.title = display;                       // full name as tooltip
        sel.appendChild(opt);
      }
      const toSet = selectedSlug || (items.some(i=>i.slug===current)? current : '');
      sel.value = toSet;
    }

    // ===== Marquee mode state =====
    const MARQUEE_FONT_KEY = 'sc_marquee_font';
    const MARQUEE_SPEED_KEY = 'sc_marquee_speed'; // px per second

    const marquee = {
      lines: [],
      cursor: 0,        // current index being shown
      running: false,
      caller: 'start',  // 'start' or 'session'
      fontPx: Math.max(24, +(localStorage.getItem(MARQUEE_FONT_KEY)||72)),
      pxPerSec: Math.max(20, +(localStorage.getItem(MARQUEE_SPEED_KEY)||80)),
      currentRAF: null,
      loop: { a: null, b: null, enabled: false, stage: 0 } // stage: 0->set A, 1->set B, 2->enable loop, 3->reset
    };

    // --- Wake Lock (keep screen on during Marquee) ---
    let wakeLock = null;
    async function acquireWakeLock(){
      if(!('wakeLock' in navigator)) return; // not supported
      try{
        if(!wakeLock){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener?.('release',()=>{ wakeLock = null; });
        }
      }catch(err){ /* ignore (e.g., tab not visible) */ }
    }
    function releaseWakeLock(){
      try{ wakeLock && wakeLock.release && wakeLock.release(); }catch{}
      wakeLock = null;
    }
    // Re-acquire on visibility gain (Android may auto-release on background)
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible' && marquee.running){ acquireWakeLock(); }
    });

    function setMarqueeFont(px){
      marquee.fontPx = Math.max(24, Math.min(200, px|0));
      localStorage.setItem(MARQUEE_FONT_KEY, marquee.fontPx);
      $('marqueeText').style.fontSize = marquee.fontPx + 'px';
    }

    function setMarqueeSpeed(pxPerSec){
      marquee.pxPerSec = Math.max(20, Math.min(600, pxPerSec|0));
      localStorage.setItem(MARQUEE_SPEED_KEY, marquee.pxPerSec);
    }

    function restartMarqueeWithNewSpeed(){
      if(!marquee.running) return;
      const el = $('marqueeText');
      const vp = $('marqueeViewport');
      let tx = 0;
      const tr = getComputedStyle(el).transform;
      if(tr && tr !== 'none'){
        const m = tr.match(/matrix\([^,]+,[^,]+,[^,]+,[^,]+,([^,]+),([^\)]+)\)/);
        if(m){ tx = parseFloat(m[1]) || 0; }
      }
      const textWidth = el.scrollWidth;
      if(!isFinite(tx) || tx === 0){ tx = vp.clientWidth; }
      el.style.transition = 'none';
      el.style.transform = `translateX(${tx}px)`;
      void el.offsetWidth;
      const remaining = Math.abs(tx - (-textWidth));
      const durationSec = remaining / marquee.pxPerSec;
      el.style.transition = `transform ${durationSec}s linear`;
      el.style.transform = `translateX(${-textWidth}px)`;
    }

    // ==== Marquee helpers for looping and navigation ====
    function marqueeHasMultiple(){ return marquee.lines && marquee.lines.length > 1; }
    function currentIndex(){ return marquee.cursor % marquee.lines.length; }
    function inRange(i,a,b){ return a<=b ? (i>=a && i<=b) : (i>=a || i<=b); }
    function normalizeRange(){
      if(marquee.loop.a==null || marquee.loop.b==null) return;
      if(marquee.loop.a===marquee.loop.b) return; // single-item loop ok
      if(marquee.loop.a > marquee.loop.b){ const t = marquee.loop.a; marquee.loop.a = marquee.loop.b; marquee.loop.b = t; }
    }
    function nextIndex(){
      const n = marquee.lines.length; if(!n) return 0;
      if(marquee.loop.enabled && marquee.loop.a!=null && marquee.loop.b!=null){
        const a = marquee.loop.a % n, b = marquee.loop.b % n;
        if(a<=b){ return (marquee.cursor < b) ? marquee.cursor+1 : a; }
        // wrapped range (rare, but handle): a..n-1 then 0..b
        return ((marquee.cursor>=a && marquee.cursor < n-1) || marquee.cursor < b) ? (marquee.cursor+1)%n : a;
      }
      return (marquee.cursor + 1) % n;
    }
    function prevIndex(){
      const n = marquee.lines.length; if(!n) return 0;
      if(marquee.loop.enabled && marquee.loop.a!=null && marquee.loop.b!=null){
        const a = marquee.loop.a % n, b = marquee.loop.b % n;
        if(a<=b){ return (marquee.cursor > a) ? marquee.cursor-1 : b; }
        // wrapped range
        return ((marquee.cursor<=b && marquee.cursor>0) || marquee.cursor > a) ? (marquee.cursor-1+n)%n : b;
      }
      return (marquee.cursor - 1 + n) % n;
    }

    function updateABButtonLabel(){
      const st = marquee.loop.stage % 4;
      $('abLoopBtn').textContent = ['a','b','L','r'][st];
    }

    function showMarqueeScreen(){
      cancelCardTimers();
      $('inputCard').style.display='none';
      $('sessionCard').style.display='none';
      $('actionBar').style.display='none';
      $('marqueeCard').style.display='block';
      // Initialize font each time shown (in case user changed settings)
      setMarqueeFont(marquee.fontPx);
      acquireWakeLock();
      document.body.classList.remove('hasBar'); // marquee has its own controls, no fixed bar
      // Make marquee full-screen and hide header/scroll
      $('marqueeCard').classList.add('fullscreen');
      document.body.style.overflow = 'hidden';
    }

    function hideMarqueeScreen(){
      releaseWakeLock();
      $('marqueeCard').classList.remove('fullscreen');
      document.body.style.overflow = '';
      $('marqueeCard').style.display='none';
      // restore previous caller screen
      if (marquee.caller === 'session') {
        $('sessionCard').style.display='block';
        $('actionBar').style.display='flex';
        document.body.classList.add('hasBar');
      } else {
        $('inputCard').style.display='block';
        document.body.classList.remove('hasBar');
      }
    }

    // ==== Refactored Marquee play logic ====
    function playMarqueeLine(text, onDone){
      const vp = $('marqueeViewport');
      const el = $('marqueeText');
      el.textContent = text;
      el.style.transition = 'none';
      const startX = vp.clientWidth;
      el.style.transform = `translateX(${startX}px)`;
      void el.offsetWidth;
      const textWidth = el.scrollWidth;
      const distance = startX + textWidth;
      const durationSec = distance / marquee.pxPerSec;
      el.style.transition = `transform ${durationSec}s linear`;
      el.style.transform = `translateX(${-textWidth}px)`;
      const handler = () => { el.removeEventListener('transitionend', handler); onDone && onDone(); };
      el.addEventListener('transitionend', handler);
    }

    function showLineAt(i){
      if(!marquee.lines.length) return;
      marquee.cursor = (i+marquee.lines.length) % marquee.lines.length;
      playMarqueeLine(marquee.lines[marquee.cursor], ()=>{
        if(!marquee.running) return;
        showLineAt(nextIndex());
      });
    }

    function startMarqueeLoop(){
      marquee.running = true;
      updateABButtonLabel();
      showLineAt(marquee.cursor || 0);
    }

    function stopMarqueeLoop(){
      marquee.running = false;
      // Stop any current transition cleanly
      const el = $('marqueeText');
      el.style.transition = 'none';
    }

    // Build JP list for a slug (reads file, parses pairs)
    async function getJPListForSlug(slug){
      if(!dirHandle) return [];
      try{
        const fh = await dirHandle.getFileHandle(filenameFromSlug(slug));
        const t = await readFileText(fh);
        const pairs = parsePairs(t);
        return pairs.map(p=>p[0]).filter(Boolean);
      }catch{
        return [];
      }
    }

    async function startMarqueeFromSelected(){
      const slug = $('setSelect').value;
      if(!slug) return;
      marquee.caller = 'start';
      marquee.lines = await getJPListForSlug(slug);
      marquee.cursor = 0;
      if(!marquee.lines.length){ showToast('No JP lines'); return; }
      // Show/hide nav controls based on number of lines
      const multi = marqueeHasMultiple();
      ['prevLineBtn','nextLineBtn','abLoopBtn'].forEach(id=>$(id).style.display = multi ? '' : 'none');
      marquee.loop = { a:null, b:null, enabled:false, stage:0 };
      updateABButtonLabel();
      showMarqueeScreen();
      startMarqueeLoop();
    }

    function startMarqueeFromSession(){
      if(!state.cards.length) return;
      marquee.caller = 'session';

      // We only want the JP string of the current card.
      // We can recover JP by checking promptSide:
      // If promptSide==='jp': current.q is JP
      // If promptSide==='en': current.a is JP
      const cur = state.cards[state.idx];
      const jp = (state.promptSide==='jp') ? cur.q : cur.a;
      marquee.lines = [jp].filter(Boolean);
      marquee.cursor = 0;
      if(!marquee.lines.length){ showToast('No JP text'); return; }
      const multi = marqueeHasMultiple();
      ['prevLineBtn','nextLineBtn','abLoopBtn'].forEach(id=>$(id).style.display = multi ? '' : 'none');
      marquee.loop = { a:null, b:null, enabled:false, stage:0 };
      updateABButtonLabel();
      showMarqueeScreen();
      startMarqueeLoop();
    }

    // Utils
    function slugify(name){
      name = String(name || '').trim();
      // Preserve a leading numeric prefix with a dot, e.g. "01." or "007."
      const m = name.match(/^\s*(\d+)\.\s*/);
      let prefix = '';
      if(m){
        prefix = m[1] + '.';                // keep exact digits + dot
        name = name.slice(m[0].length);     // remove prefix (incl. following spaces) from the remainder
      }
      // Slugify the remainder; allow dot characters; collapse spaces to underscores
      const rest = name.toLowerCase()
                       .replace(/[^\p{L}\p{N}\s._-]/gu,'')   // allow letters/numbers/space/._-
                       .trim()
                       .replace(/\s+/g,'_')
                       .replace(/_+/g,'_')
                       .replace(/^_+|_+$/g,'');
      return prefix ? (rest ? `${prefix}_${rest}` : `${prefix}`) : rest;
    }
    function titleCase(s){
      return s.toLowerCase().trim().split(/\s+/).map(w=>w? w[0].toUpperCase()+w.slice(1):'').join(' ');
    }
    // Truncate display string to avoid overflow
    function truncateString(s, max=15){
      s = String(s || '');
      return s.length > max ? s.slice(0, max) + '...' : s;
    }

    const PREFIX = 'sc_progress:';
    function keyForSlug(slug){ return PREFIX + slug; }
    function slugToNiceName(slug){ return titleCase(slug.replace(/[_-]+/g,' ')); }

    // Progress-only storage (localStorage)
    function loadProgress(slug){
      try{ return JSON.parse(localStorage.getItem(keyForSlug(slug))||'null'); }
      catch{ return null; }
    }
    function saveProgressObj(slug, obj){
      try{ localStorage.setItem(keyForSlug(slug), JSON.stringify(obj)); }catch{}
    }

    // Unnamed generator using existing files in the chosen folder
    async function nextUnnamed(){
      const files = await listDataFiles();
      const have = new Set(files.map(f=>slugFromFilename(f.name)));
      let n=1, slug;
      do { slug = slugify(`Unnamed ${n}`); n++; } while(have.has(slug));
      return { name: titleCase(slug.replace(/_/g,' ')), slug };
    }

    // Ensure slug is unique among existing files in the chosen folder
    async function ensureUniqueSlug(base){
      const files = await listDataFiles();
      const have = new Set(files.map(f=>slugFromFilename(f.name)));
      if(!have.has(base)) return base;
      let i = 2, candidate = `${base}_${i}`;
      while(have.has(candidate)){ i++; candidate = `${base}_${i}`; }
      return candidate;
    }

    // Parser ignores a first-line NAME header (case-insensitive)
    function parsePairs(text){
      const lines=text.split(/\r?\n/);
      let i=0;
      if(/^\s*NAME:\s*/i.test(lines[0]||'')){ i=1; }
      const pairs=[];
      for(; i<lines.length; ){
        const jp=(lines[i]??'').trim();
        const en=(lines[i+1]??'').trim();
        if(jp&&en){pairs.push([jp,en]);i+=2;}else{i++;}
        while(i<lines.length && !lines[i].trim()) i++;
      }
      return pairs;
    }

    const state={cards:[],idx:0,shown:false,promptSide:'jp',done:false,setName:'',setSlug:''};
    // Viewer font sizing (applies to both panels, persists)
    const VIEW_FONT_KEY = 'sc_view_font_rem';
    let viewFontRem = parseFloat(localStorage.getItem(VIEW_FONT_KEY) || '2.0');
    function applyViewFont(){
      const v = Math.max(1.0, Math.min(4.0, viewFontRem));
      ['promptArea','answerArea'].forEach(id=> $(id).style.fontSize = v + 'rem');
    }
    function bumpViewFont(delta){
      viewFontRem = Math.max(1.0, Math.min(4.0, +(viewFontRem + delta).toFixed(2)));
      localStorage.setItem(VIEW_FONT_KEY, String(viewFontRem));
      applyViewFont();
    }

    // ===== Study Card Timer =====
    const TIMER_OPTIONS = [0,10,20,30,60];
    let timerIdx = parseInt(localStorage.getItem('sc_timer_idx') || '0', 10);
    if(!(timerIdx>=0 && timerIdx<TIMER_OPTIONS.length)) timerIdx = 0;
    function timerSeconds(){ return TIMER_OPTIONS[timerIdx]; }
    function updateTimerLabel(){ const b=$('timerBtn'); if(b) b.textContent = `${timerSeconds()}s`; }
    function cycleTimer(){
      timerIdx = (timerIdx+1) % TIMER_OPTIONS.length;
      localStorage.setItem('sc_timer_idx', String(timerIdx));
      updateTimerLabel();
      cancelCardTimers();
      if(sessionActive()) scheduleCardTimer();
    }

    let revealTO=null, nextTO=null;
    function cancelCardTimers(){
      if(revealTO){ clearTimeout(revealTO); revealTO=null; }
      if(nextTO){ clearTimeout(nextTO); nextTO=null; }
    }
    function scheduleCardTimer(){
      cancelCardTimers();
      const secs = timerSeconds(); if(!secs) return; // 0s: disabled
      const ms = secs*1000;
      if(!state.shown){ // waiting to reveal answer
        revealTO = setTimeout(()=>{ if(sessionActive()) go(); }, ms);
      } else { // answer visible -> move next
        nextTO = setTimeout(()=>{ if(sessionActive()) go(); }, ms);
      }
    }

    function mapPairsToCards(pairs,side){return pairs.map(([jp,en])=>({q:side==='jp'?jp:en,a:side==='jp'?en:jp}));}

    async function startSession(){
      if(!dirHandle){ await chooseSentencesFolder(); if(!dirHandle) return; }

      const userText = $('pairs').value.trim();
      const lines = userText.split(/\r?\n/);
      const m = (lines[0]||'').match(/^\s*name:\s*(.+)/i);

      // Resolve display name and slug.
      // IMPORTANT: If user selected an existing set, preserve its slug EXACTLY ...
      let displayName, slug;
      const selectedSlug = $('setSelect').value;

      if (selectedSlug) {
        // Existing file was chosen ‚Äî default: keep its slug unchanged.
        slug = selectedSlug;
        const baselineDisplay = titleCase(slugToNiceName(selectedSlug)); // e.g., "01. Cause Reason"

        if (m) {
          // Normalize header text for consistent comparison/printing
          displayName = titleCase(m[1].trim());
          lines[0] = `NAME: ${displayName}`;

          // Only clone to a new file if the user actually changed the NAME
          // compared to what this slug normally displays as.
          if (displayName !== baselineDisplay) {
            const proposed = slugify(displayName);            // canonical base (may remove dot)
            slug = await ensureUniqueSlug(proposed);          // ensure uniqueness when cloning
          }
        } else {
          // No header present ‚Äî derive display name from slug and insert header.
          displayName = baselineDisplay;
          lines.unshift(`NAME: ${displayName}`);
        }
      } else {
        // No existing file selected ‚Äî new or pasted content
        if (m) {
          // Create a canonical slug from the provided name
          displayName = titleCase(m[1].trim());
          slug = slugify(displayName);
          lines[0] = `NAME: ${displayName}`;
        } else {
          // Completely new unnamed set
          const nu = await nextUnnamed();
          displayName = nu.name;
          slug = nu.slug;
          lines.unshift(`NAME: ${displayName}`);
        }
      }
      const textToSave = lines.join('\n');

      state.setName = displayName;
      state.setSlug = slug;

      // ---- Load saved progress FIRST so we honour saved promptSide ----
      const saved = loadProgress(slug);
      state.promptSide = (saved && saved.promptSide) ? saved.promptSide : 'jp';

      const raw = parsePairs(textToSave);
      if(raw.length===0){ alert('No pairs found'); return; }
      state.cards = mapPairsToCards(raw, state.promptSide);

      // Resume index/shown if present
      if(saved && saved.progress){
        const total = state.cards.length;
        state.idx = Math.max(0, Math.min(saved.progress.idx|0, total-1));
        state.shown = !!saved.progress.shown;
        state.done = false;
      } else {
        state.idx = 0; state.shown = false; state.done = false;
      }

      // Write deck to file (always) so source of truth is the file
      let savedOk = false;
      try{
        await writeFileText(slug, textToSave);
        savedOk = true;
      }catch(err){
        console.warn('writeFileText failed, trying Save As picker', err);
        savedOk = await saveViaPickerFallback(filenameFromSlug(slug), textToSave);
      }
      if(!savedOk){
        alert('Unable to create a new file in the selected folder on this device.\n\nTry:\n‚Ä¢ Library ‚Üí üìÅ Switch folder (e.g., Downloads/StudyCards)\n‚Ä¢ Or use ‚ÄúSave As‚Äù and then switch the app‚Äôs folder to where you saved it.');
        return;
      }

      $('inputCard').style.display='none';
      $('sessionCard').style.display='block';
      $('actionBar').style.display='flex';
      document.body.classList.add('hasBar');
      updateHUD();
      updateTimerLabel();
      scheduleCardTimer();
      // refresh select from disk to ensure presence
      await populateSetSelectFromDir(slug);
    }

    function updateHUD(){
      const current=state.cards[state.idx];
      $('progress').textContent=`${Math.min(state.idx+1,state.cards.length)} / ${state.cards.length}`;
      $('promptArea').textContent=current?.q??'';
      $('answerArea').textContent=current?.a??'';
      $('answerArea').style.opacity=state.shown?'1':'0.35';
      $('answerArea').style.filter=state.shown?'none':'blur(3px)';
      $('goBtn').textContent=state.shown?'Next':'Go';
      $('reverseBtn').textContent=state.promptSide==='jp'?'EN‚ÜíJP':'JP‚ÜíEN';
      scheduleCardTimer();
    }

    function updateStartEnabled(){
      const hasSet = $('setSelect').value !== '';
      const hasText = $('pairs').value.trim().length > 0;
      $('startBtn').disabled = !(hasSet || hasText);
      // Marquee-from-start requires a selected set
      $('marqueeBtnStart').disabled = !hasSet;
    }

    function saveProgress(){
      if(!state.setSlug) return;
      const obj = {
        name: titleCase(state.setName||slugToNiceName(state.setSlug)),
        progress: { idx: state.idx, shown: state.shown },
        promptSide: state.promptSide,
        ts: Date.now()
      };
      saveProgressObj(state.setSlug, obj);
    }

    function go(){
      if(state.cards.length===0)return;
      if(state.done){
        state.idx=0;state.shown=false;state.done=false;updateHUD();saveProgress();return;
      }
      if(!state.shown){
        state.shown=true;updateHUD();saveProgress();
      } else {
        state.idx++;
        if(state.idx>=state.cards.length){
          $('promptArea').textContent='Done!';$('answerArea').textContent='';
          $('progress').textContent=`${state.cards.length} / ${state.cards.length}`;
          state.idx=state.cards.length-1;state.done=true;$('goBtn').textContent='Restart';
          saveProgress();
        } else {
          state.shown=false;updateHUD();saveProgress();
        }
      }
    }

    function stepBack(){
      if(state.cards.length===0) return;
      if(state.shown){
        state.shown=false; state.done=false; updateHUD(); saveProgress(); return;
      }
      if(state.idx<=0) return;
      state.idx--; state.shown=false; state.done=false; updateHUD(); saveProgress();
    }

    function reverseSides(){
      state.promptSide=state.promptSide==='jp'?'en':'jp';
      for(const c of state.cards){const t=c.q;c.q=c.a;c.a=t;}
      state.shown=false;state.done=false;updateHUD();saveProgress();
    }

    function shuffleDeck(){
      if(!state.cards.length) return;
      for(let i=state.cards.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1));
        [state.cards[i],state.cards[j]]=[state.cards[j],state.cards[i]];
      }
      state.idx=0; state.shown=false; state.done=false;
      updateHUD(); saveProgress();
      showToast('Shuffled!');
    }

    async function back(){
      cancelCardTimers();
      $('sessionCard').style.display='none';
      $('actionBar').style.display='none';
      document.body.classList.remove('hasBar');
      $('inputCard').style.display='block';
      $('pairs').value='';
      if(dirHandle){ $('setSelect').disabled=false; await populateSetSelectFromDir(''); }
      else { $('setSelect').disabled=true; }
      $('setSelect').value='';
      $('startBtn').disabled = true;
      state.setSlug=''; state.setName='';
      updateStartEnabled();
    }

    function showToast(msg){
      const t=$('toast');
      t.textContent=msg;
      t.classList.add('show');
      clearTimeout(showToast._timer);
      showToast._timer=setTimeout(()=>t.classList.remove('show'), 1600);
    }

    function showBusy(msg){
      const b=$('busy'); const m=$('busyMsg');
      if(m) m.textContent = msg || 'Working‚Ä¶';
      if(b) b.style.display='flex';
    }
    function hideBusy(){ const b=$('busy'); if(b) b.style.display='none'; }

    function sessionActive(){ return $('sessionCard').style.display!=='none'; }
    
    document.addEventListener('keydown', (e)=>{
      if(!sessionActive()) return;
      const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
      if(tag==='input' || tag==='textarea' || document.activeElement.isContentEditable) return;

      if(e.key==='ArrowRight'){ e.preventDefault(); go(); }
      else if(e.key==='ArrowLeft'){ e.preventDefault(); stepBack(); }
      else if(e.key==='r' || e.key==='R'){ e.preventDefault(); reverseSides(); }
      else if(e.key==='s' || e.key==='S'){ e.preventDefault(); shuffleDeck(); }
    });
    
    $('pairs').addEventListener('input', updateStartEnabled);

    // highlight the japanese text to simplify opening in 
    // phone's Translation service
    function selectJapanese(){
      if(!sessionActive()) return;
      const el = state.promptSide==='jp' ? $('promptArea') : $('answerArea');
      try{
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        el.focus?.();
        el.click?.(); // harmless; some UIs like it
      }catch(err){ /* ignore */ }
    }

    $('startBtn').onclick=startSession;
    $('goBtn').onclick=()=>{ cancelCardTimers(); go(); };
    $('backStepBtn').onclick=()=>{ cancelCardTimers(); stepBack(); };
    $('reverseBtn').onclick=()=>{ cancelCardTimers(); reverseSides(); };
    $('shuffleTopBtn').onclick = ()=>{ cancelCardTimers(); shuffleDeck(); scheduleCardTimer(); };
    $('selectBtn').onclick = ()=>{ cancelCardTimers(); selectJapanese(); };
    $('backBtnTop').onclick=back;
    $('switchFolderBtn').onclick = chooseSentencesFolder;          // always open picker
    $('reconnectFolderBtn').onclick = ensureFolderAccessInteractive; // try stored handle
    $('syncLibraryBtn').onclick = syncLibraryIntoFolder;            // refresh from library
    $('marqueeBtnStart').onclick = startMarqueeFromSelected;
    $('marqueeBtnSession').onclick = startMarqueeFromSession;
    $('exitMarqueeBtn').onclick = () => { stopMarqueeLoop(); releaseWakeLock(); hideMarqueeScreen(); };
    $('fontUpBtn').onclick = () => setMarqueeFont(marquee.fontPx + 4);
    $('fontDownBtn').onclick = () => setMarqueeFont(marquee.fontPx - 4);
    $('speedUpBtn').onclick = () => { setMarqueeSpeed(marquee.pxPerSec + 20); restartMarqueeWithNewSpeed(); };
    $('speedDownBtn').onclick = () => { setMarqueeSpeed(marquee.pxPerSec - 20); restartMarqueeWithNewSpeed(); };
    $('timerBtn').onclick = cycleTimer;
    updateTimerLabel();
    // Marquee navigation and A/B loop controls
    $('prevLineBtn').onclick = ()=>{ if(!marquee.lines.length) return; stopMarqueeLoop(); marquee.running = true; showLineAt(prevIndex()); };
    $('nextLineBtn').onclick = ()=>{ if(!marquee.lines.length) return; stopMarqueeLoop(); marquee.running = true; showLineAt(nextIndex()); };
    $('abLoopBtn').onclick = ()=>{
      if(!marqueeHasMultiple()) return;
      const st = marquee.loop.stage % 4;
      const cur = currentIndex();
      if(st===0){ marquee.loop.a = cur; marquee.loop.stage=1; showToast('A set'); }
      else if(st===1){ marquee.loop.b = cur; marquee.loop.stage=2; showToast('B set'); }
      else if(st===2){ normalizeRange(); marquee.loop.enabled = true; marquee.loop.stage=3; showToast('Loop A‚ÄìB'); }
      else { marquee.loop = { a:null, b:null, enabled:false, stage:0 }; showToast('Loop reset'); }
      updateABButtonLabel();
    };
    // Tap panels to adjust font: Prompt = bigger, Answer = smaller
    $('promptArea').addEventListener('click', ()=>{ bumpViewFont(0.2); showToast(`Font ${viewFontRem.toFixed(1)}rem`); });
    $('answerArea').addEventListener('click', ()=>{ bumpViewFont(-0.2); showToast(`Font ${viewFontRem.toFixed(1)}rem`); });

    // Initialize stored values (in case user never opened Marquee yet)
    setMarqueeFont(marquee.fontPx);
    setMarqueeSpeed(marquee.pxPerSec);

    // Load selected set into textarea
    $('setSelect').onchange = async function(){
      const slug=this.value;
      if(!slug){
        $('pairs').value='';           // clears and shows placeholder
        updateStartEnabled();
        return;
      }
      if(!dirHandle){ return; }
      try{
        const fh = await dirHandle.getFileHandle(filenameFromSlug(slug));
        let t = await readFileText(fh);
        const name = titleCase(slugToNiceName(slug));
        t = normalizeDeckTop(t, name)
        $('pairs').value=t;
        updateStartEnabled();
      }catch(err){
        alert('Failed to read file. Did it move or get renamed?');
        await populateSetSelectFromDir('');
        updateStartEnabled();
      }
    };

    function normalizeDeckTop(text, defaultName = "Example") {
      // 1) strip all leading whitespace/newlines
      text = text.replace(/^\s+/, "");

      // 2) ensure NAME header exists (case-insensitive, tolerate weird spacing)
      const m = text.match(/^(?:NAME\s*:\s*)([^\r\n]*)/im);
      if (m) {
        const name = m[1].trim();
        text = text.replace(/^(?:NAME\s*:\s*)(.*)/im, `NAME: ${name}`);
      } else {
        text = `NAME: ${defaultName}\n\n` + text;
      }

      // 3) normalize to exactly ONE empty line after the header
      text = text.replace(/^(NAME:.*?)(\r?\n\s*)+/, "$1\n\n");

      return text;
    }

    // Delete selected set
    $('deleteSetBtn').onclick = async function(){
      const slug=$('setSelect').value;
      if(!slug){ return; }
      try{ localStorage.removeItem(keyForSlug(slug)); }catch{}
      showToast(`Cleared saved state for: ${slugToNiceName(slug)}`);
    };

    // Delete the actual set file (destructive)
    $('deleteFileBtn').onclick = async function(){
      const slug = $('setSelect').value;
      if(!slug || !dirHandle){ return; }
      try{
        await dirHandle.removeEntry(filenameFromSlug(slug));
        try{ localStorage.removeItem(keyForSlug(slug)); }catch{}
        showToast(`Deleted file: ${slugToNiceName(slug)}`);
        await populateSetSelectFromDir('');
        $('setSelect').value='';
        $('pairs').value='';
        $('startBtn').disabled = true;
      }catch(err){
        alert('Failed to delete file. Permission denied or file missing.');
      }
    };


    (async function init(){
      $('setSelect').disabled = true;
      try{
        const h = await idbGet('sentencesDir');
        if(h){
          dirHandle = h;
          const q = await dirHandle.queryPermission({ mode:'readwrite' });
          if(q==='granted'){
            $('setSelect').disabled = false;
            await populateSetSelectFromDir();
            showToast('Folder restored');
          } else {
            // On mobile, permission prompts often require a user gesture
            showToast('Tap üîå to reconnect folder');
          }
          updateStartEnabled();
        }
      }catch(err){ /* ignore */ }
      applyViewFont();
    })();
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').catch(console.error);
      });
    }
  </script>
</body>